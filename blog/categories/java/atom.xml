<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | 后端技术杂谈 | 飒然Hang]]></title>
  <link href="http://www.rowkey.me/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://www.rowkey.me/"/>
  <updated>2020-02-01T15:37:43+00:00</updated>
  <id>http://www.rowkey.me/</id>
  <author>
    <name><![CDATA[飒然Hang]]></name>
    <email><![CDATA[superhj1987@126.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Spring Boot快速开发]]></title>
    <link href="http://www.rowkey.me/blog/2019/07/27/springboot/"/>
    <updated>2019-07-27T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2019/07/27/springboot</id>
    <content type="html"><![CDATA[<p>Java开发中常用的Spring现在变得越来越复杂，越来越不好上手。这一点Spring Source自己也注意到了，因此推出了Spring Boot，旨在简化使用Spring的门槛，大大降低Spring的配置工作，并且能够很容易地将应用打包为可独立运行的程序（即不依赖于第三方容器，可以独立以jar或者war包的形式运行）。其带来的开发效率的提升使得Spring Boot被看做至少近5年来Spring乃至整个Java社区最有影响力的项目之一，也被人看作是Java EE开发的颠覆者。另一方面来说，Spring Boot也顺应了现在微服务（MicroServices）的理念，可以用来构建基于Spring框架的可独立部署应用程序。</p>

<!--more-->


<h2>一. 使用</h2>

<p>一个简单的pom配置示例如下：</p>

<pre><code>&lt;parent&gt;        
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        
   &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        
   &lt;version&gt;1.4.7.RELEASE&lt;/version&gt;
&lt;/parent&gt;

...

&lt;dependencies&gt;        
   &lt;dependency&gt;                
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                
       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        
   &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
       &lt;plugin&gt;
           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
           &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
           &lt;configuration&gt;
               &lt;executable&gt;true&lt;/executable&gt;
            &lt;/configuration&gt;
       &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>

<p>使用spring-boot-starter-parent作为当前项目的parent将Spring Boot应用相关的一系列依赖（dependency）、插件（plugins）等等配置共享；添加spring-boot-starter-web这个依赖，是为了构建一个独立运行的Web应用；spring-boot-maven-plugin用于将Spring Boot应用以可执行jar包的形式发布出去。</p>

<p>接着可以添加相应的Controller实现：</p>

<pre><code>@RestController  
public class MyController {
@RequestMapping("/")
   public String hello() {
    return "Hello World!";
   }
}
</code></pre>

<p>这里的RestController是一个复合注解，包括@Controller和@ResponseBody。</p>

<p>最后，要让Spring Boot可以独立运行和部署，我们需要一个Main方法入口， 比如：</p>

<pre><code class="">@SpringBootApplication
public class BootDemo extends SpringBootServletInitializer{    
   public static void main(String[] args) throws Exception {        
       SpringApplication.run(BootDemo.class, args);    
   }
}
</code></pre>

<p>使用mvn package打包后（可以是jar，也可以是war），java -jar xx.war/jar即可运行一个Web项目，而之所以继承SpringBootServletInitializer是为了能够让打出来的war包也可以放入容器中直接运行，其加载原理在3.4.4节的零XML配置中讲过。</p>

<p>这里需要注意上面spring-boot-maven-plugin这个插件将executable配置为了true，此种配置打出来的jar/war包其压缩格式并非传统的jar/war包，实际上是一个bash文件，可以作为shell脚本直接执行，解压的话需要使用unzip命令。</p>

<p>从最根本上来讲，Spring Boot就是一些库和插件的集合，屏蔽掉了很多配置加载、打包等自动化工作，其底层还是基于Spring的各个组件。</p>

<p>这里需要注意的是，Spring Boot推崇对项目进行零xml配置。但是就笔者看来，相比起注解配置是糅杂在代码中，每次更新都需要重新编译，XML这种和代码分离的方式耦合性和可维护性则显得更为合理一些，而且在配置复杂时也更清晰。因此，采用Java Config作为应用和组件扫描（component scan）入口，采用XML做其他的配置是一种比较好的方式。此外，当集成外部已有系统的时候， 通过XML集中明确化配置也是更为合理的一种方式。</p>

<h2>二. 原理浅析</h2>

<p><img src="//post_images/spring-boot-process.png" alt="" /></p>

<p>Spring Boot的基础组件之一就是4.1讲过的一些注解配置，除此之外，它也提供了自己的注释。其总体的运行流程如上图所示。</p>

<ol>
<li><p>@EnableAutoConfiguration</p>

<p> 这个Annotation就是Java Config的典型代表，标注了这个Annotation的Java类会以Java代码的形式（对应于XML定义的形式）提供一系列的Bean定义和实例，结合AnnotationConfigApplicationContext和自动扫描的功能，就可以构建一个基于Spring容器的Java应用了。</p>

<p> @EnableAutoConfiguration的定义信息如下 ：</p>

<pre><code class="`"> @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
 @Inherited
 @AutoConfigurationPackage
 @Import(EnableAutoConfigurationImportSelector.class)
 public @interface EnableAutoConfiguration {
</code></pre>

<p> 标注了此注解的类会发生一系列初始化动作：</p>

<ul>
<li><p>SpringBoot扫描到@EnableAutoConfiguration注解时，就使用Spring框架的SpringFactoriesLoader去扫描classpath下所有META-INF/spring.factories文件的配置信息（META-INF/spring.providers声明了当前Starter依赖的Jar包）。其中包括一些callback接口（在前中后等不同时机执行）：</p>

<ul>
<li>org.springframework.boot.SpringApplicationRunListener</li>
<li>org.springframework.context.ApplicationContextInitializer</li>
<li>org.springframework.context.ApplicationListener</li>
</ul>
</li>
<li><p>然后Spring Boot加载符合当前场景需要的配置类型并供当前或者下一步的流程使用，这里说的场景就是提取以 org.springframework.boot.autoconfigure.EnableAutoConfiguration作为key标志的一系列Java配置类，然后将这些Java配置类中的Bean定义加载到Spring容器中。</p></li>
</ul>


<p> 此外，我们可以使用Spring3系列引入的@Conditional，通过像@ConditionalOnClass、@ConditionalOnMissingBean等具体的类型和条件来进一步筛选通过SpringFactoriesLoader加载的类。</p></li>
<li><p>Spring Boot启动</p>

<p> 每一个Spring Boot应用都有一个入口类，在其中定义main方法，然后使用SpringApplication这个类来加载指定配置并运行SpringBoot Application。如上面写过的入口类：</p>

<pre><code class="`   "> @SpringBootApplication
 public class BootDemo extends SpringBootServletInitializer{    
    public static void main(String[] args) throws Exception {        
        SpringApplication.run(BootDemo.class, args);    
    }
 }
</code></pre>

<p> @SpringBootApplication注解是一个复合注解，包括了@Configuraiton、@EnableAutoConfiguration以及@ComponentScan。通过SpringApplication的run方法，Spring就使用BootDemo作为Java配置类来读取相关配置、加载和扫描相关的bean。</p>

<p> 这样，基于@SpringBootApplication注解，Spring容器会自动完成指定语义的一系列工作，包括@EnableAutoConfiguration要求的东西，如：从SpringBoot提供的多个starter模块中加载Java Config配置（META-INF/spring.factories中声明的xxAutoConfiguration），然后将这些Java Config配置筛选上来的Bean定义加入Spring容器中，再refresh容器。一个Spring Boot应用即启动完成。</p></li>
</ol>


<h2>三. 模块组成</h2>

<p>Spring Boot是由非常多的模块组成的，可以通过pom文件引入进来。EnableAutoConfiguration机制会进行插件化加载进行自动配置，这里模块化机制的原理主要是通过判断相应的类/文件是否存在来实现的。其中几个主要的模块如下:</p>

<ol>
<li><p>spring-boot-starter-web</p>

<p> 此模块就是标记此项目是一个Web应用，Spring Boot会自动准备好相关的依赖和配置。</p>

<p> 这里Spring Boot默认使用Tomcat作为嵌入式Web容器，可以通过声明spring-boot-starter-jetty的dependency来换成Jetty。</p></li>
<li><p>spring-boot-starter-logging</p>

<p> Spring Boot对此项目开启SLF4J和Logback日志支持。</p></li>
<li><p>spring-boot-starter-redis</p>

<p>  Spring Boot对此项目开启Redis相关依赖和配置来做数据存储。</p></li>
<li><p>spring-boot-starter-jdbc</p>

<p>  Spring Boot对此项目开启JDBC操作相关依赖和配置来做数据存储。</p>

<p>  这里需要说明的是，Spring Boot提供的功能非常丰富，因此显得非常笨重复杂。其实依赖于模块插件化机制，我们可以只配置自己需要使用的功能，从而对应用进行瘦身，避免无用的配置影响应用启动速度。</p></li>
</ol>


<h2>四. 总结</h2>

<p>Spring Boot给大家使用Spring做后端应用开发带来了非常大的便利，能够大大提高搭建应用雏形框架的速度，只需要关注实现业务逻辑即可。其“黑魔法”一样的插件化机制使得能够根据自己的需要引入所需的组件，提供了非常好的灵活性。如果非遗留Spring项目，直接使用Spring Boot是比较好的选择；遗留项目也可以通过配置达到无缝结合。</p>

<blockquote><p>本文节选自《Java工程师修炼之道》一书。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java开发框架之日志]]></title>
    <link href="http://www.rowkey.me/blog/2019/06/29/log/"/>
    <updated>2019-06-29T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2019/06/29/log</id>
    <content type="html"><![CDATA[<p>日志在应用开发中是一个非常关键的部分。有经验的工程师能够凭借以往的经验判断出哪里该打印日志、该以何种级别打印日志。这样就能够在线上发生问题的时候快速定位并解决问题，极大的减少应用的运维成本。</p>

<!--more-->


<p>使用控制台输出其实也算日志的一种，在容器中会打印到容器的日志文件中。但是，控制台输出过于简单，缺乏日志中级别控制、异步、缓冲等特性，因此在开发中要杜绝使用控制台输出作为日志（System.out.println）。而Java中已经有很多成熟的日志框架供大家使用：</p>

<ul>
<li>JDK Logging</li>
<li>Apache Log4j</li>
<li>Apache Log4j2</li>
<li>Logback</li>
</ul>


<p>此外，还有两个用于实现日志统一的框架：Apache Commons-Logging、SLF4j。与上述框架的不同之处在于，其只是一个门面，并没有日志框架的具体实现,可以认为是日志接口框架。</p>

<p>对于这些日志框架来说，一般会解决日志中的以下问题：</p>

<ul>
<li>日志的级别: 定义日志级别来区分不同级别日志的输出路径、形式等，帮助我们适应从开发调试到部署上线等不同阶段对日志输出粒度的不同需求。</li>
<li>日志的输出目的地：包括控制台、文件、GUI组件，甚至是套接口服务器、UNIX Syslog守护进程等。</li>
<li>日志的输出格式：日志的输出格式（JSON、XML）。</li>
<li>日志的输出优化：缓存、异步等。</li>
</ul>


<p>这里需要说的是，目前有几个框架提供了占位符的日志输出方式，然而其最终是用indexOf去循环查找再对信息进行拼接的，会消耗CPU。建议使用正确估算大小的StringBuilder拼装输出信息，除非是实在无法确定日志是否输出才用占位符。</p>

<h2>一. JDK Logging</h2>

<p>JDK Logging就是JDK自带的日志操作类，在java.util.logging包下面，通常被简称为JUL。</p>

<h3>配置</h3>

<p>JDK Logging配置文件默认位于$JAVA_HOME/jre/lib/logging.properties中，可以使用系统属性java.util.logging.config.file指定相应的配置文件对默认的配置文件进行覆盖。</p>

<pre><code>handlers= java.util.logging.FileHandler,java.util.logging.ConsoleHandler
.handlers = java.util.logging.FileHandler,java.util.logging.ConsoleHandler #rootLogger使用的Handler
.level= INFO #rootLogger的日志级别

##以下是FileHandler的配置
java.util.logging.FileHandler.pattern = %h/java%u.log
java.util.logging.FileHandler.limit = 50000
java.util.logging.FileHandler.count = 1
java.util.logging.FileHandler.formatter =java.util.logging.XMLFormatter #配置相应的日志Formatter。

##以下是ConsoleHandler的配置
java.util.logging.ConsoleHandler.level = INFO
java.util.logging.ConsoleHandler.formatter =java.util.logging.SimpleFormatter #配置相应的日志Formatter。

#针对具体的某个logger的日志级别配置
me.rowkey.pje.log.level = SEVERE

#设置此logger不会继承成上一级logger的配置
me.rokey.pje.log.logger.useParentHandlers = false 
</code></pre>

<p>这里需要说明的是logger默认是继承的，如me.rowkey.pje.log的logger会继承me.rowkey.pje的logger配置，可以对logger配置handler和useParentHandlers（默认是为true）属性, 其中useParentHandler表示是否继承父logger的配置。</p>

<p>JDK Logging的日志级别比较多，从高到低为：OFF(2<sup>31</sup>-1)—>SEVERE(1000)—>WARNING(900)—>INFO(800)—>CONFIG(700)—>FINE(500)—>FINER(400)—>FINEST(300)—>ALL(-2<sup>31</sup>)。</p>

<h3>使用</h3>

<p>JDK Logging的使用非常简单：</p>

<pre><code>public class LoggerTest{

    private static final Logger LOGGER = Logger.getLogger(xx.class.getName());

    public static void main(String[] args){
        LOGGER.info("logger info");
    }
}
...
</code></pre>

<h3>性能优化</h3>

<p>JDK Logging是一个比较简单的日志框架，并没有提供异步、缓冲等优化手段。也不建议大家使用此框架。</p>

<h2>二. Log4j</h2>

<p>Log4j应该是目前Java开发中用的最为广泛的日志框架。</p>

<h3>配置</h3>

<p>Log4j支持XML、Proerties配置，通常还是使用Properties：</p>

<pre><code>root_log_dir=${catalina.base}/logs/app/

# 设置rootLogger的日志级别以及appender
log4j.rootLogger=INFO,default

# 设置Spring Web的日志级别
log4j.logger.org.springframework.web = ERROR

# 设置default appender为控制台输出
log4j.appender.default=org.apache.log4j.ConsoleAppender
log4j.appender.default.layout=org.apache.log4j.PatternLayout
log4j.appender.default.layout.ConversionPattern=[%-d{HH\:mm\:ss} %-3r %-5p %l] &gt;&gt; %m (%t)%n

# 设置新的logger，在程序中使用Logger.get("myLogger")即可使用
log4j.logger.myLogger=INFO,A2

# 设置另一个appender为按照日期轮转的文件输出
log4j.appender.A2=org.apache.log4j.DailyRollingFileAppender
log4j.appender.A2.File=${root_log_dir}log.txt
log4j.appender.A2.Append=true
log4j.appender.A2.DatePattern= yyyyMMdd'.txt'
log4j.appender.A2.layout=org.apache.log4j.PatternLayout
log4j.appender.A2.layout.ConversionPattern=[%-d{HH\:mm\:ss} %-3r %-5p %l] &gt;&gt; %m (%t)%n

log4j.logger.myLogger1 = INFO,A3

# 设置另一个appender为RollingFileAppender，能够限制日志文件个数
log4j.appender.A3 = org.apache.log4j.RollingFileAppender
log4j.appender.A3.Append = true
log4j.appender.A3.BufferedIO = false
log4j.appender.dA3.File = /home/popo/tomcat-yixin-pa/logs/pa.log
log4j.appender.A3.Encoding = UTF-8
log4j.appender.A3.layout = org.apache.log4j.PatternLayout
log4j.appender.A3.layout.ConversionPattern = [%-5p]%d{ISO8601}, [Class]%-c{1}, %m%n
log4j.appender.A3.MaxBackupIndex = 3 #最大文件个数
log4j.appender.A3.MaxFileSize = 1024MB
</code></pre>

<p>如果Log4j文件不直接在classpath下的话，可以使用PropertyConfigurator来进行配置：</p>

<pre><code>PropertyConfigurator.configure("...");
</code></pre>

<p>Log4j的日志级别相对于JDK Logging来说，简化了一些：DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL。</p>

<p>这里的logger默认是会继承父Logger的配置（rootLogger是所有logger的父logger），如上面myLogger的输出会同时在控制台和文件中出现。如果不想这样，那么只需要如下设置:</p>

<pre><code>log4j.additivity.myLogger=false
</code></pre>

<h3>使用</h3>

<p>程序中对于Log4j的使用也非常简单：</p>

<pre><code>import org.apache.log4j.Logger;


private static final Logger LOGGER = Logger.getLogger(xx.class.getName());
...
LOGGER.info("logger info");
...
</code></pre>

<p>这里需要注意的是，虽然Log4j可以根据配置文件中日志级别的不同做不同的输出，但由于字符串创建或者拼接也是耗资源的，因此，下面的用法是不合理的。</p>

<pre><code>LOGGER.debug("...");
</code></pre>

<p>合理的做法应该是首先判断当前的日志级别是什么，再去做相应的输出，如：</p>

<pre><code>if(LOGGER.isDebugEnabled()){
    LOGGER.debug("...");
}
</code></pre>

<p>当然，如果是必须输出的日志可以不做此判断，比如catch异常打印错误日志的地方。</p>

<h3>性能优化</h3>

<p>Log4j为了应对某一时间里大量的日志信息进入Appender的问题提供了缓冲来进一步优化性能：</p>

<pre><code class="">log4j.appender.A3.BufferedIO=true   
#Buffer单位为字节，默认是8K，IO BLOCK大小默认也是8K 
log4j.appender.A3.BufferSize=8192 
</code></pre>

<p>以上表示当日志内容达到8k时，才会将日志输出到日志输出目的地。</p>

<p>除了缓冲以外，Log4j还提供了AsyncAppender来做异步日志。但是AsyncAppender只能够通过xml配置使用：</p>

<pre><code>&lt;appender name="A2"
   class="org.apache.log4j.DailyRollingFileAppender"&gt;
   &lt;layout class="org.apache.log4j.PatternLayout"&gt;
       &lt;param name="ConversionPattern" value="%m%n" /&gt;
   &lt;/layout&gt;
   &lt;param name="DatePattern" value="'.'yyyy-MM-dd-HH" /&gt;        
   &lt;param name="File" value="app.log" /&gt;
   &lt;param name="BufferedIO" value="true" /&gt;
   &lt;!-- 8K为一个写单元 --&gt;
   &lt;param name="BufferSize" value="8192" /&gt;
&lt;/appender&gt;

&lt;appender name="async" class="org.apache.log4j.AsyncAppender"&gt;
   &lt;appender-ref ref="A2"/&gt;
&lt;/appender&gt;
</code></pre>

<h2>三. Log4j2</h2>

<p>2015年8月，官方正式宣布Log4j 1.x系列生命终结，推荐大家升级到Log4j2，并号称在修正了Logback固有的架构问题的同时，改进了许多Logback所具有的功能。Log4j2与Log4j1发生了很大的变化，并不兼容。并且Log4j2不仅仅提供了日志的实现，也提供了门面，目的是统一日志框架。其主要包含两部分：</p>

<ul>
<li>log4j-api： 作为日志接口层，用于统一底层日志系统</li>
<li>log4j-core : 作为上述日志接口的实现，是一个实际的日志框架</li>
</ul>


<h3>配置</h3>

<p>Log4j2的配置方式只支持XML、JSON以及YAML，不再支持Properties文件,其配置文件的加载顺序如下：</p>

<ul>
<li>log4j2-test.json/log4j2-test.jsn</li>
<li>log4j2-test.xml</li>
<li>log4j2.json/log4j2.jsn文件</li>
<li>log4j2.xml</li>
</ul>


<p>如果想要自定义配置文件位置，需要设置系统属性log4j.configurationFile。</p>

<pre><code>System.setProperty("log4j.configurationFile", "...");
或者
-Dlog4j.configurationFile="xx"
</code></pre>

<p>配置文件示例：</p>

<p>&#8220;`</p>

<!--log4j2.xml-->


<p>&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<Configuration status="WARN" monitorInterval="30">
<Appenders>
  <Console name="Console" target="SYSTEM_OUT">
    <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
  </Console>
  <File name="File" fileName="app.log" bufferedIO="true" immediateFlush="true">
    <PatternLayout>
      <pattern>%d %p %C{1.} [%t] %m%n</pattern>
    </PatternLayout>
  </File>
  <RollingFile name="RollingFile" fileName="logs/app.log"
                     filePattern="log/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz">
      <PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss z} %-5level %class{36} %L %M - %msg%xEx%n"/>
      <SizeBasedTriggeringPolicy size="50MB"/>
      <!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 -->
      <DefaultRolloverStrategy max="20"/>
  </RollingFile>
</Appenders>
<Loggers>
  <logger name="myLogger" level="error" additivity="false">
    <AppenderRef ref="File" />
  </logger>
  <Root level="debug">
    <AppenderRef ref="Console"/>
  </Root>
</Loggers>
</Configuration>
&#8220;`</p>

<p>上面的monitorInterval使得配置变动能够被实时监测并更新，且能够在配置发生改变时不会丢失任何日志事件;additivity和Log4j一样也是为了让Looger不继承父Logger的配置；Configuration中的status用于设置Log4j2自身内部的信息输出，当设置成trace时，你会看到Log4j2内部各种详细输出。</p>

<p>Log4j2在日志级别方面也有了一些改动：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL, 并且能够很简单的自定义自己的日志级别。</p>

<pre><code>&lt;CustomLevels&gt;
    &lt;CustomLevel name="NOTICE" intLevel="450" /&gt;
    &lt;CustomLevel name="VERBOSE" intLevel="550" /&gt;
&lt;/CustomLevels&gt;
</code></pre>

<p>上面的intLevel值是为了与默认提供的标准级别进行对照的。</p>

<h3>使用</h3>

<p>使用方式也很简单：</p>

<pre><code>private static final Logger LOGGER = LogManager.getLogger(xx.class);

LOGGER.debug("log4j debug message");
</code></pre>

<p>这里需要注意的是其中的Logger是log4j-api中定义的接口，而Log4j1中的Logger则是类。</p>

<p>相比起之前我们需要先判断日志级别，再输出日志，Log4j2提供了占位符功能：</p>

<pre><code>LOGGER.debug("error: {} ", e.getMessage());
</code></pre>

<h3>性能优化</h3>

<p>在性能方面，Log4j2引入了基于LMAX的Disruptor的无锁异步日志实现进一步提升异步日志的性能：</p>

<pre><code>&lt;AsyncLogger name="asyncTestLogger" level="trace" includeLocation="true"&gt;
    &lt;AppenderRef ref="Console"/&gt;
&lt;/AsyncLogger&gt;
</code></pre>

<p>需要注意的是，由于默认日志位置信息并没有被传给异步Logger的I/O线程，因此这里的includeLocation必须要设置为true。</p>

<p>和Log4j一样，Log4j2也提供了缓冲配置来优化日志输出性能。</p>

<pre><code>&lt;Appenders&gt;
  &lt;File name="File" fileName="app.log" bufferedIO="true" immediateFlush="true"&gt;
    &lt;PatternLayout&gt;
      &lt;pattern&gt;%d %p %C{1.} [%t] %m%n&lt;/pattern&gt;
    &lt;/PatternLayout&gt;
  &lt;/File&gt;
&lt;/Appenders&gt;
</code></pre>

<h2>四. Logback</h2>

<p>Logback是由Log4j创始人设计的又一个开源日志组件，相对Log4j而言，在各个方面都有了很大改进。</p>

<p>Logback当前分成三个模块：</p>

<ul>
<li>logback-core是其它两个模块的基础模块。</li>
<li>logback-classic是Log4j的一个改良版本。logback-classic完整实现SLF4J API使你可以很方便地更换成其它日志系统如Log4j或JDK Logging。</li>
<li>logback-access访问模块与Servlet容器集成提供通过HTTP来访问日志的功能。</li>
</ul>


<h3>配置</h3>

<p>Logback的配置文件如下：</p>

<p>&#8220;`</p>

<!--logback.xml-->


<p>&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<configuration></p>

<pre><code>&lt;property name="root_log_dir" value="${catalina.base}/logs/app/"/&gt;

&lt;appender name="ROLLING_FILE_APPENDER" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
   &lt;File&gt;${root_log_dir}app.log&lt;/File&gt;
   &lt;Append&gt;true&lt;/Append&gt;
   &lt;encoder&gt;
       &lt;pattern&gt;%date [%level] [%thread] %logger{80} [%file : %line] %msg%n&lt;/pattern&gt;
   &lt;/encoder&gt;
   &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
       &lt;fileNamePattern&gt;${root_log_dir}app.log.%d{yyyy-MM-dd}.%i&lt;/fileNamePattern&gt;
       &lt;maxHistory&gt;30&lt;/maxHistory&gt; #只保留最近30天的日志文件
       &lt;TimeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt;#每天的日志按照100MB分割
            &lt;MaxFileSize&gt;100MB&lt;/MaxFileSize&gt;
        &lt;/TimeBasedFileNamingAndTriggeringPolicy&gt;
        &lt;totalSizeCap&gt;20GB&lt;/totalSizeCap&gt;#日志总的大小上限，超过此值则异步删除旧的日志
   &lt;/rollingPolicy&gt;
&lt;/appender&gt;

&lt;appender name="ROLLING_FILE_APPENDER_2" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
   &lt;File&gt;${root_log_dir}mylog.log&lt;/File&gt;
   &lt;Append&gt;true&lt;/Append&gt;
   &lt;encoder&gt;
       &lt;pattern&gt;%date [%level] [%thread] %logger{80} [%file : %line] %msg%n&lt;/pattern&gt;
   &lt;/encoder&gt;
   #下面的日志rolling策略和ROLLING_FILE_APPENDER的等价，保留最近30天的日志，每天的日志按照100MB分隔，日志总的大小上限为20GB
   &lt;rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"&gt;
        &lt;fileNamePattern&gt;mylog.log-%d{yyyy-MM-dd}.%i&lt;/fileNamePattern&gt;
        &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;
        &lt;maxHistory&gt;30&lt;/maxHistory&gt;
        &lt;totalSizeCap&gt;20GB&lt;/totalSizeCap&gt;
    &lt;/rollingPolicy&gt;
&lt;/appender&gt;

 &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
   &lt;encoder&gt;
     &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
   &lt;/encoder&gt;
 &lt;/appender&gt;

&lt;logger name="myLogger" level="INFO" additivity="false"&gt;
    &lt;appender-ref ref="ROLLING_FILE_APPENDER" /&gt;
&lt;/logger&gt;

 &lt;root level="DEBUG"&gt;          
   &lt;appender-ref ref="STDOUT" /&gt;
 &lt;/root&gt;  
</code></pre>

<p></configuration>
&#8220;`</p>

<p>Logback的配置文件读取顺序（默认都是读取classpath下的）：logback.groovy -> logback-test.xml -> logback.xml。如果想要自定义配置文件路径，那么只有通过修改logback.configurationFile的系统属性。</p>

<pre><code>System.setProperty("logback.configurationFile", "...");
或者
-Dlogback.configurationFile="xx"
</code></pre>

<p>Logback的日志级别：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR。如果logger没有被分配级别，那么它将从有被分配级别的最近的祖先那里继承级别。root logger 默认级别是 DEBUG。</p>

<p>Logback中的logger同样也是有继承机制的。配置文件中的additivit也是为了不去继承rootLogger的配置，从而避免输出多份日志。</p>

<p>为了方便Log4j到Logback的迁移，官网提供了log4j.properties到logback.xml的转换工具：<a href="https://logback.qos.ch/translator/">https://logback.qos.ch/translator/</a>。</p>

<h3>使用</h3>

<p>Logback由于是天然与SLF4J集成的，因此它的使用也就是SLF4J的使用。</p>

<pre><code>import org.slf4j.LoggerFactory;

private static final Logger LOGGER=LoggerFactory.getLogger(xx.class);

LOGGER.info(" this is a test in {}", xx.class.getName())
</code></pre>

<p>SLF4J同样支持占位符。</p>

<p>此外，如果想要打印json格式的日志（例如，对接日志到Logstash中），那么可以使用logstash-logback-encoder做为RollingFileAppender的encoder。</p>

<pre><code>&lt;encoder class="net.logstash.logback.encoder.LogstashEncoder" &gt;
...
&lt;/encoder&gt;
</code></pre>

<h3>性能优化</h3>

<p>Logback提供了AsyncAppender进行异步日志输出，此异步appender实现上利用了队列做缓冲，使得日志输出性能得到提高。</p>

<pre><code>&lt;appender name="FILE_APPENDER" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
      &lt;File&gt;${root_log_dir}app.log&lt;/File&gt;
      &lt;Append&gt;true&lt;/Append&gt;
      &lt;encoder&gt;
          &lt;pattern&gt;%date [%level] [%thread] %logger{80} [%file : %line] %msg%n&lt;/pattern&gt;
      &lt;/encoder&gt;
      &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
          &lt;fileNamePattern&gt;${root_log_dir}app.log.%d&lt;/fileNamePattern&gt;
      &lt;/rollingPolicy&gt;
&lt;/appender&gt;
&lt;appender name ="ASYNC" class= "ch.qos.logback.classic.AsyncAppender"&gt;  
       &lt;discardingThreshold &gt;0&lt;/discardingThreshold&gt;  

       &lt;queueSize&gt;512&lt;/queueSize&gt;  

       &lt;appender-ref ref ="FILE_APPENDER"/&gt;  
&lt;/appender&gt;  
</code></pre>

<p>这里需要特别注意以下两个参数的配置：</p>

<ul>
<li>queueSize：队列的长度,该值会影响性能，需要合理配置。</li>
<li>discardingThreshold：日志丢弃的阈值，即达到队列长度的多少会丢弃TRACT、DEBUG、INFO级别的日志，默认是80%，设置为0表示不丢弃日志。</li>
</ul>


<p>此外，由于是异步输出，为了保证日志一定会被输出以及后台线程能够被及时关闭，在应用退出时需要显示关闭logback。有两种方式：</p>

<ul>
<li><p>在程序退出的地方（ServletContextListener的contextDestroyed方法、Spring Bean的destroy方法）显式调用下面的代码。</p>

<pre><code class="``">  LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
  loggerContext.stop();
</code></pre></li>
<li><p>在logback配置文件里，做如下配置。</p>

<pre><code class="``">  &lt;configuration&gt;

      &lt;shutdownHook class="ch.qos.logback.core.hook.DelayingShutdownHook"/&gt;
      .... 
  &lt;/configuration&gt;
</code></pre></li>
</ul>


<h2>五. 日志门面</h2>

<p>前面的四个框架是实际的日志框架。对于开发者而言，每种日志都有不同的写法。如果我们以实际的日志框架来进行编写，代码就限制死了，之后就很难再更换日志系统，很难做到无缝切换。</p>

<p>Java开发中经常提到面向接口编程，所以我们应该是按照一套统一的API来进行日志编程，实际的日志框架来实现这套API，这样的话，即使更换日志框架，也可以做到无缝切换。</p>

<p>这就是Commons-Logging与SLF4J这种日志门面框架的初衷。</p>

<h3>Apache Commons-Logging</h3>

<p>Apache Commons-Logging经常被简称为JCL，是Apache开源的日志门面框架。Spring中使用的日志框架就是JCL，使用起来非常简单。</p>

<pre><code>import org.apache.commons.logging.LogFactory;

private static final Log LOGGER = LogFactory.getLog(xx.class);

LOGGER.info("...");
</code></pre>

<p>使用JCL需要先引入JCL的依赖：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;commons-logging&lt;/groupId&gt;
    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
    &lt;version&gt;xx&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>再来看一下如何让JCL使用其他日志实现框架:</p>

<ol>
<li>这里当没有其他日志jar包存在的时候，JCL有自己的默认日志实现，默认的实现是对JUL的包装，即当没有其他任何日志包时，通过JCL调用的就是JUL做日志操作。</li>
<li>使用Log4j作为日志实现框架，那么只需要引入Log4j的jar包即可。</li>
<li><p>使用Log4j2作为日志实现，那么除了Log4j2的jar包，还需要引入Log4j2与Commons-Logging的集成包（使用SPI机制提供了自己的LogFactory实现）：</p>

<pre><code class="`"> &lt;dependency&gt;
     &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
     &lt;artifactId&gt;log4j-jcl&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre></li>
<li><p>使用Logback作为日志实现，那么由于Logback的调用是通过SLF4J的，因此需要引入jcl-over-slf4j包（直接覆盖了JCL的类），并同时引入SLF4J以及Logback的jar包。</p>

<pre><code class="`"> &lt;dependency&gt;
     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
     &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre></li>
</ol>


<h3>SLF4J</h3>

<p>SLF4J（Simple Logging Facade for Java）为Java提供的简单日志Facade。允许用户以自己的喜好，在工程中通过SLF4J接入不同的日志实现。与JCL不同的是，SLF4J只提供接口，没有任何实现（可以认为Logback是默认的实现）。</p>

<p>SLF4J的使用前提是引入SLF4J的jar包:</p>

<p>&#8220;`</p>

<!-- SLF4J -->


<p><dependency>
   <groupId>org.slf4j</groupId>
   <artifactId>slf4j-api</artifactId>
   <version>xx</version>
</dependency>
&#8220;`</p>

<p>再看一下SLF4J如何和其他日志实现框架集成。</p>

<ol>
<li><p>使用JUL作为日志实现，需要引入slf4j-jdk14包。</p>

<pre><code class="`"> &lt;dependency&gt;
     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
     &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre></li>
<li><p>使用Log4j作为日志实现，需要引入slf4j-log4j12和log4j两个jar包。</p>

<pre><code class="`"> &lt;!-- slf4j-log4j --&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
     &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;!-- log4j --&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;log4j&lt;/groupId&gt;
     &lt;artifactId&gt;log4j&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre></li>
<li><p>使用Log4j2作为日志实现，需要引入log4j-slf4j-impl依赖。</p>

<pre><code class="`"> &lt;!-- log4j2 --&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
     &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
     &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
     &lt;version&gt;xx/version&gt;
 &lt;/dependency&gt;
 &lt;!-- log4j-slf4j-impl （用于log4j2与slf4j集成） --&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
     &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre></li>
<li><p>使用Logback作为日志实现，只需要引入logback包即可。</p></li>
</ol>


<h2>六. 日志集成</h2>

<p>上面说到了四种日志实现框架和两种日志门面框架。面对这么多的选择，即便是一个刚刚开始做的应用，也会由于依赖的第三方库使用的日志框架五花八门而造成日志配置和使用上的烦恼。得益于JCL和SLF4J，我们可以很容易的把日志都统一为一种实现，从而可以进行集中配置和使用。这里就以用Logback统一日志实现为例：</p>

<ol>
<li><p>配置好Logback的依赖：</p>

<pre><code class="`"> &lt;!-- slf4j-api --&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
     &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;!-- logback --&gt;
 &lt;dependency&gt; 
     &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; 
     &lt;artifactId&gt;logback-core&lt;/artifactId&gt; 
     &lt;version&gt;xx&lt;/version&gt; 
 &lt;/dependency&gt;
 &lt;!-- logback-classic（已含有对slf4j的集成包） --&gt; 
 &lt;dependency&gt; 
     &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; 
     &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; 
     &lt;version&gt;xx&lt;/version&gt; 
 &lt;/dependency&gt;
</code></pre></li>
<li><p>切换Log4j到SLF4J</p>

<pre><code class="`"> &lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;
    &lt;version&gt;xx&lt;/verison&gt;
&lt;/dependency&gt;
</code></pre></li>
<li><p>切换JUL到SLF4J</p>

<pre><code class="`"> &lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;
    &lt;version&gt;xx&lt;/verison&gt;
 &lt;/dependency&gt;
</code></pre></li>
<li><p>切换JCL到SLF4J</p>

<pre><code class="`"> &lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
    &lt;version&gt;xx&lt;/verison&gt;
 &lt;/dependency&gt;
</code></pre></li>
</ol>


<p>这里需要注意的是，做了以上配置后，务必要排除其他日志包的存在，如Log4j。此外，在日常开发中经常由于各个依赖的库间接引入了其他日志库，造成日志框架的循环转换。比如同时引入了log4j-over-slf4j和slf4j-log4j12的情况，当使用SLF4J调用日志操作时就会形成循环调用。</p>

<p>笔者目前比较推崇的是使用SLF4J统一所有框架接口，然后都转换到Logback的底层实现。但这里需要说明的是Logback的作者是为了弥补Log4j的各种缺点而优化实现了SLF4J以及Logback，但不知为何作者又推出了Log4j2以期取代Log4j和Logback。所以，如果是一个新的项目，那么直接跳过Log4j和Logback选择Log4j2也是一个不错的选择, 官网也提供了Log4j到Log4j2的迁移说明。</p>

<blockquote><p>本文节选自《Java工程师修炼之道》一书。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin语法简明指南]]></title>
    <link href="http://www.rowkey.me/blog/2018/12/08/kotlin-notes/"/>
    <updated>2018-12-08T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2018/12/08/kotlin-notes</id>
    <content type="html"><![CDATA[<p>Kotlin是Intellij IDEA的发明团队JetBrains带来的新一代JVM语言。虽然JVM上一次又一次出现新的语言叫嚣着取代Java，但时至今日，Java也开始吸纳其他语言的各种优势，其生命力依旧强盛，生态也越发强大。那么Kotlin的出现是又一次重蹈覆辙还是有其突破性的特性？</p>

<p>本文对其语法作了简要概括。</p>

<!--more-->


<p><strong>Kotlin版本：1.3.11</strong></p>

<ol>
<li><p>包的定义</p>

<p> 与Java类似，但包的定义与目录结构无需匹配，源代码可以在文件系统任意位置。</p>

<p> 与Java有一点不同，导入包的时候，可以使用import as实现重命名来解决名字冲突的问题。如：</p>

<pre><code class="`"> import me.rowkey.MainClass as aClass // aClass 代表“me.rowkey.MainClass”
</code></pre></li>
<li><p>没有类型的Java</p>

<p> 虽然Kotlin是静态语言，但其引入的安全类型推断让其无须声明类型。使用val/var即可，其中val定义只读变量，var定义可变变量。</p>

<pre><code class="`"> var str1 : String = "a" //有初始值，可以省略类型
 val str2 : String //无初始值，不能省略类型
 str2 = "b"
 var str = "i can change"
 val immutableStr = "i cannot change"
</code></pre></li>
<li><p>不需要的public</p>

<p> Kotlin中默认的可见性修饰符是public，所以public修饰符不需要写。其他修饰符如下：</p>

<ul>
<li>private：只在类内部/声明文件内部可见。</li>
<li>protected：private+子类中可见。</li>
<li>internal: 同一模块（编译在一起的一套Kotlin文件）可见。</li>
</ul>
</li>
<li><p>函数定义</p>

<p> 用fun关键字声明函数</p>

<pre><code class="`"> fun main(args: Array&lt;String&gt;) {
  ...
 }
</code></pre>

<p> 其中，函数参数使用 Pascal 表示法定义，即 name: type。参数用逗号隔开。每个参数必须有显式类型。</p>

<p> Kotlin中还能够直接通过表达式做为函数体来定义函数。</p>

<pre><code class="`"> fun sum(a : Int, b : Int) = a + b
</code></pre>

<p> Kotlin中的函数和Java中的方法是一致的，但与Java不同的是，Kotlin中的函数可以属于任何类，文件当中直接定义则作为“包级函数”，和类的使用方式一致</p></li>
<li><p>默认参数值</p>

<p> 函数的参数可以指定默认值。</p>

<pre><code class="`"> fun getList(list: Array&lt;String&gt;, offset: Int = 0, size: Int = list.size) { …… }
</code></pre>

<p> 不指定第2个参数调用方法时，offset参数取默认值0, size参数默认取第一个参数的size。</p></li>
<li><p>可变参数</p>

<p> 函数的参数（通常是最后一个）可以用 vararg 修饰符标记：</p>

<pre><code class="`"> fun printIntArray(vararg input: Int) {
     for (i in input) {
         println(i)
     }
 }
</code></pre></li>
<li><p>不需要的语句结束符</p>

<p> Kotlin中没有语句结束符，当然为了与java保持一致性，也可以使用;号作为语句结束符。</p></li>
<li><p>字符串连接符</p>

<p> 跟java一样，如果你需要把一个字符串写在多行里，可以使用+号连接字符串。代码可以这样写：</p>

<pre><code>val str = "hello" + "world" + "!!!";
</code></pre>

<p> Kotlin中的写法也可以这样：</p>

<pre><code class="`"> val str = """hello
 world
 !!!
 """
</code></pre>

<p> 三个”号之间不在需要+号进行连接，不过字符串中的格式符都会被保留，包括回车和tab。</p></li>
<li><p>字符串模板</p>

<p> Kotlin提供了$符来做字符串内的变量替换，并且可以做一些字符串操作。如下：</p>

<pre><code class="`"> var name = "hj"
 var strTemplate = "My name is $name"//My name is hj

 strTemplate = "My name is ${name.replace("j","a")}"// My name is ha
</code></pre></li>
<li><p>一切皆对象</p>

<p> Kotlin中一切皆对象。即使赋值为基本数据类型，也会自动转换为对应的类。</p></li>
<li><p>if条件表达式</p>

<p> Kotlin中支持if条件表达式。</p>

<pre><code class="`">val a = if(x &gt; 0) 1 else 2
fun maxOf(a: Int, b: Int) = if (a &gt; b) a else b
</code></pre></li>
<li><p>循环</p>

<p> Kotlin的while循环和Java没什么不同, 在for循环引入了区间的概念。</p>

<pre><code class="`"> for(i in 1..10){
     println(i)
 }

 for(i in 1..10 step 2){
     println(i)
 }

 for(i in 10 downTo 1 step 1){
     println(i)
 }

 for (i in 1 until 10) {
     // i in [1, 10) 排除了 10
     println(i)
 }

 for(c in 'A'..'Z'){
     println(c)
 }
</code></pre>

<p> 需要注意的是在Kotlin中不再支持Java的for循环形式：</p>

<pre><code class="`"> for(int i =0;i &lt; 10;i++){
     ...
 }
</code></pre></li>
<li><p>when</p>

<p>  Kotlin中没有switch。提供when做分支条件选择。</p>

<pre><code class="``">  when (x) {
     1 -&gt; print("x == 1")
     2 -&gt; print("x == 2")
     3, 4 -&gt; print("x == 3 or x == 4")
     in 10..99999 -&gt; print("x &gt; 10")
     else -&gt; { // 注意这个块
         print("x is neither 1 nor 2")
     }
 }

 when {
     x.isOdd() -&gt; print("x is odd")
     x.isEven() -&gt; print("x is even")
     else -&gt; print("x is funny")
  }
</code></pre>

<p>   when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式， 符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。</p></li>
<li><p>操作符重载</p>

<p> Kotlin提供了操作符重载的支持。对于常用的”+“、&#8221;-&ldquo;等操作符，创建带有operator且名称符合要求的方法，即可实现。如：</p>

<pre><code class="`"> data class Point(val x: Int, val y: Int)

 operator fun Point.unaryMinus() = Point(-x, -y)

 val point = Point(10, 20)

 fun main() {
     println(-point)  // 输出“Point(x=-10, y=-20)”
 }
</code></pre>

<p> 上面即完成了对-的重载。</p></li>
<li><p>集合</p>

<p>Kotlin把集合分为可变集合和不可变集合。其创建需要通过标准库的方法：listOf()、 mutableListOf()、 setOf()、 mutableSetOf()、hashMapOf()、mutableHashMapOf()</p>

<pre><code>val list = listOf("1","2","3",""4)
val set = setOf("1","2")
val map = hashMapOf("name" to "hj","sex" to "male")
</code></pre>

<p>这些集合类实现了操作符重载，如下：</p>

<pre><code>val list1 = list - listOf("1","2")
val list2 = list + "2"
println(list1[0])

val map = hashMapOf("name" to "hj","sex" to "male")
val map1 = map + ("name2" to "hah") //{"name":"hj","name2":"ha","sex":"male"}
val map2 = map - "name"//{"sex":"male"}
println(map2)
</code></pre>

<p>Map的遍历如下：</p>

<pre><code>for ((k, v) in map) {
    println("$k -&gt; $v")
}
</code></pre>

<p>Kotlin中的集合具有类似Java中的Stream的操作如filter、map、foreach等。</p>

<pre><code>val positives = list.filter { x -&gt; x &gt; 0 }
//val positives = list.filter { it &gt; 0 }
</code></pre></li>
<li><p>Elvis操作符</p>

<p> 三目运算符通常以这种形式出现：</p>

<pre><code class="`"> String displayName = name != null ? name : "Unknown";
</code></pre>

<p> Kotlin中可以简化为：</p>

<pre><code class="`"> val displayName = name ?: "Unknown";
</code></pre></li>
<li><p>可空/非可空引用/函数返回值</p>

<p> Kotlin中区分一个引用可以容纳null和不能容纳null。默认的引用是不可空的。</p>

<pre><code class="`"> var a = "abc"
 a = null // 编译错误    ```
</code></pre>

<p> 需要使用?使其变为可空引用。</p>

<pre><code class="`"> var b : String ? = "abc"
 b = null
</code></pre>

<p> 如此，后续如果你调用a的任何方法都可以，但是调用b的会有编译错误。会强制去检查b是否为空</p>

<pre><code class="`"> val l = if (b != null) b.length else -1
</code></pre>

<p> 也可以使用?做安全调用</p>

<pre><code class="`"> b?.length()
</code></pre>

<p> b不为空才会执行后续的操作。配合let可以执行其他非自身的操作。</p>

<pre><code class="`"> b?.let{
     print("a")
 )
</code></pre>

<p> 同样的，对于函数参数以及返回值，默认也是非空的，只有加了?才允许传控制且要求做空值检测。</p>

<pre><code class="`"> fun parseInt(str: String?): Int? {
     // ……
     if(str == null){
         return null
     }

     ...
     return ..
 }

 val r = parseInt(null)
 r?.let{
     print r
 }
</code></pre></li>
<li><p>try with resources</p>

<pre><code class="`"> val stream = Files.newInputStream(Paths.get("/some/file.txt"))
 stream.buffered().reader().use { reader -&gt;
     println(reader.readText())
 }
</code></pre></li>
<li><p>延迟属性</p>

<p> Kotlin提供了延迟属性的支持，即只有在你第一次开始使用的时候才会真正初始化。默认使用同步锁保证只有一个线程初始化。下面例子改成了不使用同步锁，可以多线程执行。</p>

<pre><code class="`"> val p by lazy(LazyThreadSafetyMode.PUBLICATION) {
     println("computed!")
     "Hello"
 }
 println(p)
</code></pre></li>
<li><p>类</p>

<ul>
<li>无须public修饰符。文件名和类也没有任何关联。</li>
<li><p>创建对象不需要使用new关键字</p>

<pre><code class="``">  val test = Test()
</code></pre></li>
<li><p>对于类属性，默认会有get()和set()两个方法。直接访问属性或者给属性设置值都会调用这两个方法。</p>

<pre><code class="``">  class Test {
      var counter = 0 // 注意：这个初始器直接为幕后字段赋值
      get() {
          println("getter")
          return field
      }
      set(value) {
          println("setter")
          field = value
      }


  }

  val test = Test()
  test.counter = 10
  println(test.counter)
</code></pre></li>
<li><p>主构造函数和次构造函数。Kotlin中一个类可以有一个主构造函数以及一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（与可选的类型参数）后。主构造函数里的参数如果用val或者var修饰则成为类的属性。如果类有一个主构造函数，每个次构造函数需要委托给主构造函数。主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块（即时没有主构造函数，也会在次构造函数前执行）。</p>

<pre><code class="``">  class Test(val counter: Int, val name: String = "test") {

      init{

      }

      constructor(counter: Int, name: String, sex: String) : this(counter, name) {

      }

  }

  val test = Test(10)
  println(test.counter)
</code></pre></li>
<li><p>Kotlin中引入了解构函数来对对象进行解构。</p>

<pre><code class="``">  class Test(val counter: Int, val name: String = "test") {

      operator fun component1() : Int{
          return counter
      }

      operator fun component2() : String{
          return name
      }

  }

  val (counter,name) = Test(10)
</code></pre>

<p>  如此，也和map一样可以用在集合迭代中。</p>

<pre><code class="``">  val testList = listOf(Test(1),Test(2))
  for((k,v) in testList){
      ...
  }
</code></pre></li>
<li><p>Kotlin中引入了数据类的概念。对于此种类，会默认根据主构造函数的属性生成equals()/hashCode()、toString()、componentN()、copy()这几个函数。</p>

<pre><code class="``">  data class User(val name: String, val age: Int)
</code></pre></li>
<li><p>Kotlin中提供了对象声明来实现单例模式。</p>

<pre><code class="``">  object SingleInstance {
      fun test(input: String) = println(input)
  }

  fun main(args: Array&lt;String&gt;) {
      SingleInstance.test("hj")
  }
</code></pre></li>
<li><p>Kotlin中提供了密封类来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型时。可以看做是枚举类的扩展。密封类需要在类名前面添加 sealed 修饰符。其所有子类都必须在与密封类自身相同的文件中声明。</p>

<pre><code class="``">  sealed class DataType
  data class Card(val number: Double) :DataType()
  data class Timeline(val e1: DataType, val e2: DataType) : DataType()
  object Illegal : DataType()
</code></pre></li>
<li><p>Kotlin的类中引入了伴生对象来声明静态方法、属性以及编译期常量（也可以在object中定义）。</p>

<pre><code class="``">  class Test(val counter: Int, val name: String = "test") {

      companion object {
          const val TYPE = 1
              val title = "haha"

              fun testStatic(){
              println("static method")
          }
  }
</code></pre></li>
<li><p>对一个对象调用多个方法。</p>

<pre><code class="``">  class Test(val counter : Int){
      fun test1(){

      }

      fun test2(){

      }
  }


  val test = Test(1)
  with(test){
      test1()
      test2()
  }
</code></pre></li>
</ul>
</li>
</ol>


<p>以上为Kotlin中的基本语法说明，其他诸如委托、lambda函数、协程、与Java互操作等可见<a href="https://www.kotlincn.net/docs/reference/">https://www.kotlincn.net/docs/reference/</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何进行Java项目构建？]]></title>
    <link href="http://www.rowkey.me/blog/2018/08/30/build-java/"/>
    <updated>2018-08-30T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2018/08/30/build-java</id>
    <content type="html"><![CDATA[<p><strong>最新版本可见:<a href="https://github.com/superhj1987/pragmatic-java-engineer/blob/master/book/chapter2-project/build.md">https://github.com/superhj1987/pragmatic-java-engineer/blob/master/book/chapter2-project/build.md</a></strong></p>

<p>对于一个完整的项目来说，一般都有很多的类、很多的包，如果是Web工程那么还有很多jsp、资源文件。这时候如果只用JDK自带的工具编译和运行，是非常困难的一件事前。再者，编译源代码只是软件开发过程的一个方面，更重要的是要把软件发布到生产环境中来产生商业价值。所以，代码编译之后，还有测试、分析代码质量、部署等步骤要做。整个过程进行自动化操作是很有必要的。</p>

<p>这时候就需要一个Java的工程/项目构建工具。这里所谓的项目构建就是指的完成工程发布流程需要的一系列步骤，包括编译、测试、打包、部署等等。虽然用Eclipse和Intellij这些IDE能解决这个问题，但是受限于这些IDE体积庞大且基本上都是GUI的，而后端应用的运行环境基本都是没有显示器的，所以很多时候还是需要一些专门做项目构建的工具来支持这些工作。</p>

<!--more-->


<ul>
<li><a href="#%E4%B8%80.%20Ant">一. Ant</a>

<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">使用示例</a></li>
<li><a href="#%E6%8F%90%E7%A4%BA">提示</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C.%20Maven">二. Maven</a>

<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li>
<li><a href="#%E6%A0%87%E5%87%86Web%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84">标准Web项目结构</a></li>
<li><a href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86">依赖管理</a></li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B">项目构建流程</a></li>
<li><a href="#Profile%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81">Profile多环境支持</a></li>
<li><a href="#%E5%A4%8D%E7%94%A8test">复用test</a></li>
<li><a href="#Scala%E6%94%AF%E6%8C%81">Scala支持</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6">常用插件</a></li>
<li><a href="#%E6%8F%90%E7%A4%BA">提示</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89.%20Gradle">三. Gradle</a>

<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">使用示例</a></li>
<li><a href="#%E5%A4%9A%E6%A8%A1%E5%9D%97">多模块</a></li>
<li><a href="#%E6%8F%90%E7%A4%BA">提示</a></li>
</ul>
</li>
</ul>


<h2><a name='一. Ant'></a>一. Ant</h2>

<h3><a name='介绍'></a>介绍</h3>

<p>Ant的全称是Another Neat Tool，意为另一个好用的工具，是Java中比较常用的项目构建工具。构建过程包括编译、测试和部署等。概括来看具有以下三个特点：</p>

<ul>
<li>和传统的Make工具相似，能为我们完成工程发布流程中一系列机械工作。并且具有良好的跨平台特性。</li>
<li>使用XML来表述构建过程与依赖关系，用task替代shell，语义清晰，便于维护。</li>
<li>具有强大的任务系统，便于扩展。其中，task以Java class的形式存在。</li>
</ul>


<p>为了方便使用，Ant自带了很多默认的task，如：</p>

<ul>
<li>echo: 输出信息</li>
<li>mkdir: 创建文件夹</li>
<li>exec: 执行shell命令</li>
<li>delete: 删除文件</li>
<li>copy: 复制文件</li>
</ul>


<p>通过组合这些默认task和自己实现的task就能够完成Java项目的构建任务。</p>

<h3><a name='使用示例'></a>使用示例</h3>

<p>使用Ant需要编写build.xml来配置任务流程。当然，可以通过-f参数指定其他配置文件作为任务流程描述文件。一个Ant的配置文件如下：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project name="helloWorld" basedir="." default="usage"&gt;
    &lt;property name="mvn" value="mvn"/&gt;
    &lt;property name="script.lock" value="/build_home/scripts/lock"/&gt;

    &lt;target name="usage" description="Prints out instructions"&gt;
        &lt;echo message="使用 'lock' 加锁"/&gt;
        &lt;echo message="使用 'unlock' 解锁"/&gt;
        &lt;antcall target="compile"&gt;
            &lt;param name="profile" value="test"/&gt;
        &lt;/antcall&gt;
    &lt;/target&gt;

    &lt;target name="lock"&gt;
        &lt;exec dir="${basedir}" executable="${script.lock}" errorproperty="lock.err"/&gt;
        &lt;fail message="u can use 'ant unlcok to force redeploy'...'"&gt;
            &lt;condition&gt;
                &lt;contains string="${lock.err}" substring="locked"/&gt;
            &lt;/condition&gt;
        &lt;/fail&gt;
    &lt;/target&gt;

    &lt;target name="unlock"&gt;
        &lt;delete file="${basedir}/.lock"/&gt;
    &lt;/target&gt;

    &lt;target name="compile"&gt;
        &lt;echo message="编译开始"/&gt;
        &lt;exec dir="${basedir}" executable="${mvn}" failonerror="true"&gt;
            &lt;arg line="compile -P ${profile}"/&gt;
        &lt;/exec&gt;
        &lt;exec executable="${mvn}" failonerror="true"&gt;
            &lt;arg value="war:exploded"/&gt;
        &lt;/exec&gt;
    &lt;/target&gt;

    &lt;!--逻辑判断--&gt;
    &lt;target name="testIf" depends="check" if="flag"&gt;
        &lt;echo message="if..."/&gt;
    &lt;/target&gt;

    &lt;target name="testUnless" depends="check" unless="flag"&gt;
        &lt;echo message="unless..."/&gt;
    &lt;/target&gt;

    &lt;target name="check"&gt;
        &lt;condition property="flag"&gt;
            &lt;or&gt;
              &lt;and&gt;
                 &lt;isset property="name"/&gt;
                 &lt;equals arg1="${version}" arg2="1.0" /&gt;
              &lt;/and&gt;
              &lt;available file="/project.version" type="file"/&gt;
            &lt;/or&gt;
        &lt;/condition&gt;
    &lt;/target&gt;
    &lt;!--逻辑判断end--&gt;

&lt;/project&gt;
</code></pre>

<p>可见，Ant使用顶级元素<project>描述整个工程,使用<property>描述全局属性, 用<target>定义工程中的target以及target间的依赖, 在target中定义task的执行流程。使用antcall来调用target，通过其子节点param传递参数。</p>

<p>此外，在很多场景下需要用到逻辑判断，如if等。Ant中的if如上面的例子所示，是需要搭配target和condition使用的。上面配置中最后的逻辑判断部分，类似如下伪代码：</p>

<pre><code>if (name ！= null &amp;&amp; version.equals("1.0")) || fileExist("/project.version") ){
    echo "if..."
}else{
    echo "unless..."
}
</code></pre>

<p>执行<code>ant [target]</code>即可执行任务流程。</p>

<h3><a name='提示'></a>提示</h3>

<ul>
<li>使用Ant时，一个常见的需求就是通过命令行给Ant传递参数，可以通过<code>-Dname=value</code>这种形式来传递，在build.xml中通过<code>${name}</code>来引用即可。</li>
<li><p>对于配置文件中重复出现的元素，可以通过refid引用，减少重复配置。</p>

<pre><code class="``">  &lt;project&gt;
      &lt;path id="project.class.path"&gt;
          &lt;pathelement location="lib/"/&gt;
          &lt;pathelement location="${java.class.path}/"/&gt;
      &lt;/path&gt;

      &lt;target ...&gt;
          &lt;rmic ...&gt;
              &lt;classpath refid="project.class.path"/&gt;
          &lt;/rmic&gt;
      &lt;/target&gt;

      &lt;target ...&gt;
          &lt;javac ...&gt;
              &lt;classpath refid="project.class.path"/&gt;
          &lt;/javac&gt;
      &lt;/target&gt;
  &lt;/project&gt;
</code></pre></li>
</ul>


<h2><a name='二. Maven'></a>二. Maven</h2>

<h3><a name='介绍'></a>介绍</h3>

<p>Maven是继Ant后出现的一款基于约定优于配置原则的项目构建工具。这里所说的“约定优于配置”指的是约定的一些规范无需再配置，例如：其约定好的生命周期、项目结构等。当然，Maven也提供了打破默认约定的配置办法。</p>

<p>概括来讲，Maven具有以下的功能：</p>

<ul>
<li>依赖管理：Maven能够帮助我们解决软件包依赖的管理问题，不再需要提交大量的jar包，引入第三方lib也不需要关心其依赖。</li>
<li>规范目录结构：标准的目录结构有助于项目构建的标准化，使得项目更整洁，还可通过配置profile根据环境的不同读取不同的配置文件。</li>
<li>可以通过每次发布都更新版本号以及统一依赖配置文件来规范软件包的发布。</li>
<li>完整的项目构建阶段：Maven能够对项目完整阶段进行构建。</li>
<li>支持多种插件：面向不同类型的工程项目提供不同的插件。</li>
<li>方便集成：能够集成在IDE中方便使用，和其他自动化构建工具也都能配合使用。</li>
</ul>


<p>可见，相比起Ant，Maven提供了更加强大和规范的功能。</p>

<h3><a name='配置文件'></a>配置文件</h3>

<p>Maven基于pom（Project Object Model）进行。一个项目所有的配置都放置在pom.xml文件中，包括定义项目的类型、名字，管理依赖关系，定制插件的行为等等。</p>

<pre><code>&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;me.rowkey&lt;/groupId&gt;
    &lt;artifactId&gt;test&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;rowkey&lt;/name&gt;
    &lt;url&gt;http://maven.apache.org&lt;/url&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;nexus-suishen&lt;/id&gt;
            &lt;name&gt;Nexus suishen&lt;/name&gt;
            &lt;url&gt;http://maven.etouch.cn/nexus/content/groups/public/&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;true&lt;/enabled&gt;
                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;
                &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt;
            &lt;/snapshots&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;properties&gt;
        &lt;slf4j.version&gt;1.7.21&lt;/slf4j.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.8.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.3.2&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.7&lt;/source&gt;
                    &lt;target&gt;1.7&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

    &lt;!--发布配置，用户名和密码需要在$M2_HOME/conf/settings.xml中配置server--&gt;
    &lt;distributionManagement&gt;
        &lt;repository&gt;
            &lt;id&gt;suishen-release&lt;/id&gt;
            &lt;name&gt;Suishen-Releases&lt;/name&gt;
            &lt;url&gt;http://maven.etouch.cn/nexus/content/repositories/Suishen-Releases&lt;/url&gt;
        &lt;/repository&gt;

        &lt;snapshotRepository&gt;
            &lt;id&gt;suishen-snapshot&lt;/id&gt;
            &lt;name&gt;Suishen-Snapshots&lt;/name&gt;
            &lt;url&gt;http://maven.etouch.cn/nexus/content/repositories/Suishen-Snapshots&lt;/url&gt;
        &lt;/snapshotRepository&gt;
    &lt;/distributionManagement&gt;

&lt;/project&gt;
</code></pre>

<p>其中，</p>

<ul>
<li>Maven使用groupId:artifactId:version三者来唯一标识一个唯一的二进制版本，可以缩写为GAV。</li>
<li>packaging代表打包方式，可选的值有: pom, jar, war, ear, custom，默认为jar。</li>
<li>properties是全局属性的配置</li>
<li>dependencies是对于依赖的管理</li>
<li>plugins是对于插件的管理。</li>
</ul>


<p>此外，可以通过parent实现pom的继承做统一配置管理，子pom中的配置优先级高于父pom。</p>

<pre><code>&lt;?xml version=”1.0″ encoding=”UTF-8″?&gt;

&lt;project&gt;

…

&lt;parent&gt;

    &lt;artifactId&gt;suishen-parent&lt;/artifactId&gt;

    &lt;groupId&gt;suishen&lt;/groupId&gt;

    &lt;version&gt;1.0&lt;/version&gt;

&lt;/parent&gt;

…

&lt;/project&gt;
</code></pre>

<p>可以继承的元素如下：</p>

<ul>
<li>groupId,version</li>
<li>Project Config</li>
<li>Dependencies</li>
<li>Plugin configuration</li>
</ul>


<p>此外，<dependencyManagement>和<pluginManagement>可以统一做依赖和插件的配置管理，不同于<dependencies>和<plugins>的是，如果子pom中没有声明<dependency>和<plugin>则并不生效。</p>

<h3><a name='标准Web项目结构'></a>标准Web项目结构</h3>

<p>在Maven中，一个Web项目的标准结构，如下图所示：</p>

<p><img src="//post_images/buildjava/mvn-web-arch.png" alt="" /></p>

<p>其中：</p>

<ul>
<li>src/main/java         Java代码目录</li>
<li>src/main/resources    配置文件目录</li>
<li>src/main/webapp       webapp根目录</li>
<li>src/test/java         测试代码目录</li>
<li>src/test/resources    测试配置目录</li>
<li>target/classes        代码编译结果目标目录</li>
<li>target/test-classes   测试代码编译结果目标目录</li>
</ul>


<p>当然，结构是可以自定义的。</p>

<pre><code> &lt;build&gt;
   &lt;plugins&gt;
       &lt;plugin&gt;
           &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
           &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
           &lt;configuration&gt;
               &lt;warSourceDirectory&gt;WebContent/&lt;/warSourceDirectory&gt;
           &lt;/configuration&gt;
       &lt;/plugin&gt;
   &lt;/plugins&gt;
   &lt;sourceDirectory&gt;src&lt;/sourceDirectory&gt;
   &lt;testSourceDirectory&gt;test/java&lt;/testSourceDirectory&gt;
   &lt;testResources&gt;
       &lt;testResource&gt;
           &lt;directory&gt;test/resources&lt;/directory&gt;
       &lt;/testResource&gt;
   &lt;/testResources&gt;
   &lt;directory&gt;build&lt;/directory&gt;
&lt;/build&gt;
</code></pre>

<p>这里，Java代码目录移到了./src中，测试代码目录到了./test/java中，测试资源也到了./test/resources,同时编译结果目录变为了./build。此外，在maven-war-plugin中，也把Web目录的war源码目录改为了./WebContent。</p>

<h3><a name='依赖管理'></a>依赖管理</h3>

<p>依赖管理是通过<dependencies>来定义的，其中：</p>

<ul>
<li>一项jar包依赖可以由groupId:artifactId:version标识</li>
<li>完整的标识为：groupId:artifactId:type:classifier:version</li>
<li>依赖在编译部署中参与的情况可以由scope来指定, 分为: compile、test、provided、system、import，默认为compile。其中的import是在Maven 2.0.9后引入的，仅仅支持在<dependencyManagement>中使用，导入外部的依赖版本管理。</li>
<li>依赖是一个树状结构，采用<strong>最近依赖</strong>原则，也可以通过exclusions标签来排除一些包。这里的最近依赖指的是在依赖树中，离当前结点最近的依赖优先级高，同样远时第一个优先。</li>
</ul>


<p>依赖下载的过程一般如下图所示：</p>

<p><img src="//post_images/buildjava/mvn-dependency-download.png" alt="" /></p>

<p>但上面的示例配置中，如果有一个repsitory的配置，那么依赖下载的过程则发生了改变。</p>

<p><img src="//post_images/buildjava/mvn-dependency-download-1.png" alt="" /></p>

<p>此外，Maven中还有一个镜像库的配置，即在Maven的settings.xml中配置Maven镜像库。和pom.xml中的repository不同的是镜像会拦截住对远程中央库的请求，只在镜像库中进行依赖的搜索以及下载。而如果只是配置了repository，那么在repository中找不到相应的依赖时，会继续去远程中央库进行搜索和下载。</p>

<p>上面所说的镜像库和repository可以通过<a href="http://www.sonatype.org/nexus/">http://www.sonatype.org/nexus/</a>进行搭建。</p>

<h3><a name='项目构建流程'></a>项目构建流程</h3>

<p>Maven的构建生命周期中几个常见phase如下：</p>

<ul>
<li>validate：验证项目以及相关信息是否正确</li>
<li>compile：编译源代码和相关资源文件</li>
<li>test：对测试代码进行测试</li>
<li>package：根据项目类型的不同进行打包</li>
<li>verify： 验证打包的正确性</li>
<li>install：将打好的包安装到本地</li>
<li>deploy：将打好的包发布到远程库中</li>
</ul>


<p>当然，对应上述每一个phase,还有pre、post、proces做前缀的一些phase。还有一些在命令行中不常用的phase如：test-compile、integration-test等。</p>

<p>针对于Java Web项目，一个完整的项目构建流程如下图所示：</p>

<p><img src="//post_images/buildjava/mvn-process.png" alt="" /></p>

<h3><a name='Profile多环境支持'></a>Profile多环境支持</h3>

<p>现实开发中一个很常见的需求就是需要根据不同的环境打包不同的文件或者读取不同的属性值。Maven中的profile即可解决此问题。</p>

<pre><code>&lt;profiles&gt;
   &lt;profile&gt;
       &lt;id&gt;dev&lt;/id&gt;
       &lt;activation&gt;
           &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
       &lt;/activation&gt;
       &lt;properties&gt;
           &lt;resources.dir&gt;src/main/resources/dev&lt;/resources.dir&gt;
       &lt;/properties&gt;
   &lt;/profile&gt;
   &lt;profile&gt;
       &lt;id&gt;test&lt;/id&gt;
       &lt;properties&gt;
           &lt;resources.dir&gt;src/main/resources/test&lt;/resources.dir&gt;
       &lt;/properties&gt;
   &lt;/profile&gt;
   &lt;profile&gt;
       &lt;id&gt;prod&lt;/id&gt;
       &lt;properties&gt;
           &lt;resources.dir&gt;src/main/resources/prod&lt;/resources.dir&gt;
       &lt;/properties&gt;
   &lt;/profile&gt;

&lt;/profiles&gt;

&lt;build&gt;
    &lt;filters&gt;  
        &lt;filter&gt;${user.home}/love.properties&lt;/filter&gt;  
    &lt;/filters&gt;  
   &lt;resources&gt;
       &lt;resource&gt;
           &lt;directory&gt;${resources.dir}&lt;/directory&gt;
           &lt;filtering&gt;true&lt;/filtering&gt;  
           &lt;includes&gt;  
               &lt;include&gt;**/*&lt;/include&gt; 
           &lt;/includes&gt; 
        &lt;/resource&gt;
       &lt;resource&gt;
           &lt;directory&gt;src/main/resources&lt;/directory&gt;
           &lt;filtering&gt;true&lt;/filtering&gt;  
           &lt;includes&gt;  
               &lt;include&gt;**/*&lt;/include&gt; 
           &lt;/includes&gt; 
       &lt;/resource&gt;
   &lt;/resources&gt;
&lt;/build&gt;
</code></pre>

<p>如此，分为dev、test以及prod三种环境，对应每一种环境，其资源文件路径都不一样。在使用mvn时，使用-P参数指定profile即可生效。</p>

<p>此外，示例中resource下的filtering设置为true, 是为了能够在编译过程中将资源文件中的占位符替换为Maven中相应属性对应的值。例如，在resources下的config.properties文件内容：</p>

<pre><code>resouceDir=${resources.dir}
</code></pre>

<p>在profile为dev时，编译结束此文件会变为:</p>

<pre><code>resouceDir=src/main/resources/dev
</code></pre>

<p>而示例中的filters配置则是将外部文件的属性引入进来，同样也能够使用占位符。</p>

<p>如果是Web项目，想要在webapp下使用占位符，那么则需要配置maven-war-plugin:</p>

<pre><code>&lt;plugin&gt;  
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  
    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;  
    &lt;configuration&gt;  
        &lt;webResources&gt;  
            &lt;resource&gt;  
                &lt;filtering&gt;true&lt;/filtering&gt;  
                &lt;directory&gt;src/main/webapp&lt;/directory&gt;  
                &lt;includes&gt;  
                    &lt;include&gt;**/*&lt;/include&gt;  
                &lt;/includes&gt;  
            &lt;/resource&gt;  
        &lt;/webResources&gt;  
        &lt;warSourceDirectory&gt;src/main/webapp&lt;/warSourceDirectory&gt;  
        &lt;webXml&gt;src/main/webapp/WEB-INF/web.xml&lt;/webXml&gt;  
    &lt;/configuration&gt;  
&lt;/plugin&gt;  
</code></pre>

<h3><a name='复用test'></a>复用test</h3>

<p>当需要将写的测试用例（src/test下的资源和类）以jar包形式发布出去的时候，需要用到test-jar。首先，在打包时配置maven-jar-plugin，如下：</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
         &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;test-jar&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;excludes&gt;
                    &lt;exclude&gt;*.conf&lt;/exclude&gt;
                    &lt;exclude&gt;**/*.*.conf&lt;/exclude&gt;
                    &lt;exclude&gt;logback.xml&lt;/exclude&gt;
                &lt;/excludes&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
        &lt;excludes&gt;
            &lt;exclude&gt;*.conf&lt;/exclude&gt;
            &lt;exclude&gt;**/*.*.conf&lt;/exclude&gt;
            &lt;exclude&gt;*.properties&lt;/exclude&gt;
            &lt;exclude&gt;logback.xml&lt;/exclude&gt;
        &lt;/excludes&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<p>使用时，指定dependency的type为test-jar：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;xx&lt;/groupId&gt;
    &lt;artifactId&gt;xx&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;type&gt;test-jar&lt;/type&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<h3><a name='Scala支持'></a>Scala支持</h3>

<p>Scala的官方构建工具是sbt，但是由于某些原因，在国内访问很慢。Maven有插件提供了对Scala项目的支持。</p>

<pre><code>&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;
            &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.1.6&lt;/version&gt;
            &lt;executions&gt;
               &lt;execution&gt;
                   &lt;id&gt;scala-compile-first&lt;/id&gt;
                   &lt;phase&gt;process-resources&lt;/phase&gt;
                   &lt;goals&gt;
                       &lt;goal&gt;add-source&lt;/goal&gt;
                       &lt;goal&gt;compile&lt;/goal&gt;
                   &lt;/goals&gt;
               &lt;/execution&gt;
               &lt;execution&gt;
                   &lt;id&gt;scala-test-compile&lt;/id&gt;
                   &lt;phase&gt;process-test-resources&lt;/phase&gt;
                   &lt;goals&gt;
                       &lt;goal&gt;testCompile&lt;/goal&gt;
                   &lt;/goals&gt;
               &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
           &lt;groupId&gt;org.scalatest&lt;/groupId&gt;
           &lt;artifactId&gt;scalatest-maven-plugin&lt;/artifactId&gt;
           &lt;version&gt;1.0-RC2&lt;/version&gt;
           &lt;configuration&gt;
               &lt;reportsDirectory&gt;${project.build.directory}/surefire-reports&lt;/reportsDirectory&gt;
               &lt;junitxml&gt;.&lt;/junitxml&gt;
               &lt;filereports&gt;TestSuite.txt&lt;/filereports&gt;
               &lt;stdout&gt;testOutput&lt;/stdout&gt;
           &lt;/configuration&gt;
           &lt;executions&gt;
               &lt;execution&gt;
                   &lt;id&gt;test&lt;/id&gt;
                   &lt;goals&gt;
                       &lt;goal&gt;test&lt;/goal&gt;
                   &lt;/goals&gt;
               &lt;/execution&gt;
           &lt;/executions&gt;
        &lt;/plugin&gt;
       &lt;plugin&gt;
           &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
           &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;
           &lt;version&gt;1.2.1&lt;/version&gt;
           &lt;configuration&gt;
               &lt;executable&gt;scala&lt;/executable&gt;
               &lt;arguments&gt;
                   &lt;argument&gt;-classpath&lt;/argument&gt;
                   &lt;classpath/&gt;
                   &lt;argument&gt;&lt;/argument&gt;
               &lt;/arguments&gt;
           &lt;/configuration&gt;
       &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>

<p>net.alchim31.maven.scala-maven-plugin提供了对Scala代码的编译；org.scalatest.scalatest-maven-plugin提供了对Scala项目的测试；exec-maven-plugin配置了对Scala程序的执行。</p>

<h3><a name='常用插件'></a>常用插件</h3>

<p>Maven提供了很多插件方便开发工作。</p>

<ul>
<li><p>maven-source-plugin</p>

<p>  源码发布插件，绑定在compile阶段，执行jar goal, 将源码以jar包的形式发布出去。</p></li>
<li><p>maven-javadoc-plugin</p>

<p>  javadoc插件，将源码的javadoc发布出去。</p></li>
<li><p>maven-archetype-plugin</p>

<p>  使用此插件可以定制/使用项目模板。定制模板可以遵循archetype的结构编写文件，也可以使用mvn archetype:create-from-project从一个现有的项目生成；使用模板通过archetype:generate即可。</p></li>
<li><p>maven-tomcat7-plugin</p>

<p>  此插件可以直接使用Tomcat运行web项目，常用的命令是：<code>mvn tomcat7:run</code>。同样的还有jetty-maven-plugin。</p></li>
<li><p>maven-shade-plugin</p>

<p>  此插件是maven常用打包插件，一般是将其绑定在package阶段，执行其shade goal。能够将源码和依赖的第三方资源打包在一起以供独立运行。</p></li>
<li><p>maven-assesmbly-plugin</p>

<p>  和maven-shade-plugin一样也是打包插件，但是其功能更加强大，输出压缩包格式除了jar还支持tar、zip、gz等。</p></li>
<li><p>maven-gpg-plugin</p>

<p>  此插件是jar包的签名插件，可以对自己发布的jar包进行签名。</p></li>
</ul>


<h3><a name='提示'></a>提示</h3>

<ul>
<li>在项目版本号中加入<code>SNAPSHOT</code>后缀做为快照版本可以使得Maven每次都能自动获取最新版本而无需频繁更新版本号。</li>
<li><code>mvn -DNAME=test</code>可以传递给pom参数，使用${NAME}引用即可。</li>
<li><p>在dependency中设置optional为true, 可使得此依赖不传递出去。如下：</p>

<pre><code class="``">  ...
  &lt;artifactId&gt;suishen-libs&lt;/artifactId&gt;
  ...

  ...
  &lt;dependency&gt;
     &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
     &lt;artifactId&gt;httpasyncclient&lt;/artifactId&gt;
     &lt;version&gt;4.1.3&lt;/version&gt;
     &lt;optional&gt;true&lt;/optional&gt;
  &lt;/dependency&gt;
  ...
</code></pre>

<p>  如此，依赖于suishen-lib的项目除非在自己的pom里显示声明，否则不会依赖于httpasyncclient。</p></li>
<li><p>由于Maven自定义plugin的复杂度，不够灵活，因此很多时候都是结合Ant的灵活性和Maven一起使用的。</p>

<pre><code class="``">  &lt;target name="compile" depends="clean"&gt;
    &lt;exec executable=“mvn"&gt;
            &lt;arg line="compile"/&gt;
    &lt;/exec&gt;
  &lt;/target&gt;

  &lt;target name="compile" depends="clean"&gt;
    &lt;exec executable=“cmd"&gt;
            &lt;arg line=“/c mvn compile"/&gt;
    &lt;/exec&gt;
  &lt;/target&gt;
</code></pre></li>
<li><p>日常开发中一个工程可能比较庞大，这时可以把这个工程拆分成多个子模块来管理。一个多模块工程包含一个父pom，在其中定义了它的子模块，每个子模块都是一个独立的工程。</p>

<pre><code class="``">  &lt;project&gt;
      …
      &lt;packaging&gt;pom&lt;/packaging&gt;

      &lt;modules&gt;
          &lt;module&gt;module-1&lt;/module&gt;
          &lt;module&gt;module-2&lt;/module&gt;
      &lt;/modules&gt;
  &lt;/project&gt;
</code></pre></li>
<li>可以使用第三方的takari/maven-wrapper(<code>mvn -N io.takari:maven:wrapper -Dmaven=3.3.3</code>)来做Maven操作（<code>./mvnw clean</code>），从而可以达到类似gradle wrapper的功能：不用预先安装好Maven，还能够统一项目所使用的Maven版本。</li>
</ul>


<h2><a name='三. Gradle'></a>三. Gradle</h2>

<h3><a name='介绍'></a>介绍</h3>

<p>Gradle是目前正在开始流行的新一代构建工具，正在逐步的被大家推广使用，尤其以Android为典型。基本上现在所有的Android项目都采用Gradle做为项目构建工具。概括来讲，有以下几个特点：</p>

<ul>
<li>采用了Groovy DSL来定义配置，相比起XML更加易于学习和使用，并大大简化了构建代码的行数。此外，这种“配置即代码”的方式能够大大简化配置学习和插件编写的成本，提供了更好的灵活性。</li>
<li>在构建模型上非常灵活。可以轻松创建一个task，并随时通过depends语法建立与已有task的依赖关系。这里Gradle使用了Java插件来支持Java项目的标准构建生命周期（和Maven类似）。</li>
<li>依赖的scope简化为compile、runtime、testCompile、testRuntime四种。</li>
<li>支持动态的版本依赖。在版本号后面使用+号的方式可以实现动态的版本管理。</li>
<li>支持排除传递性依赖或者干脆关闭传递性依赖。</li>
<li>完全支持Maven、Ivy的资源库（Repository）。</li>
</ul>


<h3><a name='使用示例'></a>使用示例</h3>

<p>Gradle的配置写在build.gradle文件中。</p>

<pre><code>apply plugin: 'groovy'
apply plugin: 'idea'
apply plugin: 'checkstyle'

// --- properties ---
ext.ideaInstallationPath = '/Applications/IntelliJ IDEA.app/Contents'
ext.pomCfg = {
  name 'me.rowkey.libs'
  description '&lt;project_desc&gt;'
  ...
}
sourceCompatibility = 1.6
// --- properties ---

//源码目录结构
sourceSets.main.java.srcDirs = []
sourceSets.main.groovy.srcDir 'src/main/java'

//增加repository
repositories {
    mavenLocal()
    maven{
        url "http://maven.etouch.cn/nexus/content/groups/public/"
    }
    mavenCentral()
}

//依赖管理
dependencies {
    compile fileTree(dir: ideaInstallationPath + '/lib', include: '*.jar')
    testCompile 'org.mockito:mockito-core:2.0.3-beta'
    testCompile 'org.assertj:assertj-core:1.7.1'
    testCompile 'org.springframework:spring-test:4.0.0.RELEASE'

    // 排除全部或特定的间接依赖
    runtime ('commons-dbcp:commons-dbcp:1.4') {
        transitive = false
        // 或 exclude group: xxx, module: xxx
    }

    // 然后显式声明
    runtime 'commons-pool:commons-pool:1.6'
}

//for gradle wrapper
task wrapper(type: Wrapper) {
    gradleVersion = '3.0'
}

task helloWorld

helloWorld &lt;&lt; {
    println "Hello World!"
}

task testA(dependsOn:helloWorld)

testA &lt;&lt; {
    println "test"
}
task copyFile(type: Copy)
//task(copyFile(type: Copy))

copyFile {
    from 'xml'
    into 'destination'
}

//发布到Maven库的配置
uploadArchives {
  repositories {
    mavenDeployer {
      repository(url: &lt;repo_url&gt;) {
       //身份认证信息推荐放在$HOME/.gradle/gradle.properties中
        authentication(
          userName: &lt;repo_user&gt;,
          password: &lt;repo_passwd&gt;)
      }
      pom.project pomCfg
    }
  }
}
</code></pre>

<p>可见，依赖的配置（dependencies）相比Maven,得到了大大的简化，对于任务的定义（task）也非常简单。</p>

<h3><a name='多模块'></a>多模块</h3>

<ul>
<li><p>首先，在工程的根目录下，创建settings.gradle。</p>

<pre><code class="``">  include "common", "api"
</code></pre>

<p>  以上即表示包含根目录下的两个子模块common和api。</p></li>
<li><p>在根目录的build.gradle中定义公共构建逻辑：</p>

<pre><code class="``">  subprojects {
      apply plugin: 'java'

      repositories {
          mavenCentral()
      }

      // 所有的子模块共同的依赖
      dependencies {
          ...
      }
  }
</code></pre>

<p>  subprojects中定义的内容对所有子模块都有效，包括属性、依赖以及Task定义。</p>

<p>  需要注意的是在多模块配置下，gradle命令会对所有子模块都执行。如果想要针对单个模块，需要指定模块前缀，如: gradle :common:clean</p></li>
<li><p>在子模块下创建build.gradle，其中的配置可以增量覆盖父工程中的公共配置。如:</p>

<pre><code class="``">  ...

  dependencies {
      compile project(':common')
      ...
  }
</code></pre>

<p>  以上声明了此模块依赖于common模块，当构建此模块时会首先编译打包common模块。相比起Maven每次都要install所依赖的模块，大大简化了使用。</p></li>
</ul>


<h3><a name='提示'></a>提示</h3>

<ul>
<li>gradle -Penv=test可以传递参数，使用env引用即可。这里需要注意的是Gradle中默认并没有提供Maven的profile支持，但是可以利用-P参数自己实现此功能。</li>
<li>Gradle中的配置中的语法和平常所见的Groovy非常不同, 其利用了Groovy的AST转换等特性实现了自己的一套语法。</li>
<li>建议使用<strong>gradle wrapper</strong>（gradle wrapper &ndash;gradle-version 3.0）来做gradle操作（./gradlew clean）。一方面可以使得项目成员不用预先安装好Gradle，还能够统一项目所使用的Gradle版本。</li>
<li>务必要保持构建脚本简洁、清晰，如：把属性、常量（如版本号）放到gradle.properties中。</li>
<li>模块化构建脚本，通过plugin机制在多个项目中重用，共享相关的配置：apply from: <link_to_gradle>。通过此种方式可以统一团队或者公司的一些构建规范、依赖版本等。</li>
</ul>


<blockquote><p>本文节选自《Java工程师修炼之道》一书。</p></blockquote>

<p><img src="http://www.rowkey.me/post_images/book-all.png" width="400"/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java后端技术概览]]></title>
    <link href="http://www.rowkey.me/blog/2018/05/12/java-tech-overview/"/>
    <updated>2018-05-12T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2018/05/12/java-tech-overview</id>
    <content type="html"><![CDATA[<p>一个合格的Java后端工程师需要掌握哪些技能呢？扫描下面的二维码可以看到<a href="https://raw.githubusercontent.com/superhj1987/pragmatic-java-engineer/master/book/server-tech/media/java-skill-tree.png">Java后端技术概览图</a>。</p>

<p><img src="https://raw.githubusercontent.com/superhj1987/pragmatic-java-engineer/master/book/chapter1-servertech/media/tech-tree.png" alt="" /></p>

<!--more-->


<h2>软件开发的核心原则</h2>

<p>此处所说的是软件开发应该遵循的一些核心原则：</p>

<ul>
<li>Don&rsquo;t Repeat Yourself: 这是软件开发的一个基础原则，即不要做重复性劳动。也是现在所说的“极客文化”的一种。代码重复、工作重复在软件开发中都是不合理的存在。利用各种手段消除这些重复是软件开发的一个核心工作准则。</li>
<li>Keep it simple stupid：即KISS原则。在做软件设计的工作中，很多时候都不要想得过于复杂，也不要过度设计和过早优化，用最简单且行之有效的方案也就避免了复杂方案带来的各种额外成本。既有利于后续的维护，也利于进一步的扩展。</li>
<li>You Ain’t Gonna Need It: 即YAGNI原则。只需要将应用程序必需的功能包含进来，而不要试图添加任何其他你认为可能需要的功能。因为在一个软件中，往往80%的请求都花费在20%的功能上。</li>
<li>Done is better than perfect: 在面对一个开发任务时，最佳的一个思路就是先把东西做出来，再去迭代优化。如果一开始就面面俱到，考虑到各种细节，那么很容易陷入牛角尖而延误项目进度。</li>
<li>Choose the most suitable things: 这是在做方案选择、技术选型时候的一个很重要的原则。在面对许多技术方案、开源实现的时候，务必做到的是不能盲目求新，要选择最合适的而非被吹得天花乱坠的。</li>
</ul>


<h2>软件过程</h2>

<p>一个软件的生命周期中，除了开发还有很多其他步骤，也都是需要掌握的一些技术。</p>

<ul>
<li>项目管理：项目管理对于一个软件的开发是非常重要的，能够保证项目进度有条不紊地进行，在可控的时间内以一定的质量交付。瀑布开发模型、螺旋开发模型是传统的项目管理模型。在互联网的开发工作中，敏捷开发则是比较受推崇的开发方式。所谓敏捷开发即快速实现原型，然后快速迭代。Scrum是目前普遍流行的敏捷开发方式之一。</li>
<li>测试驱动开发：在平时的开发过程中，目前比较流行也是行之有效的一种方式就是Test Driven Develop，即测试驱动开发。此种方式的核心就是编写单元测试。简单来讲，就是先完成某一个功能的单元测试用例，然后在逐步消除测试用例的编译错误的过程中完成功能的开发。</li>
<li>持续集成：某一个软件功能完成开发之后，后续还有测试、预发布、部署等过程。整个过程称之为集成，而持续集成指的是无需人工干预可以不断地进行这个过程。Jenkins、Quick Build以及后起之秀Travis CI都是比较典型的持续集成工具。 此外，持续集成的子过程持续部署指的是将集成结果部署到不同的环境供用户使用，并且立即反馈部署结果，Rundeck是这方面用的比较多的软件。它提供了Web界面和命令行来执行shell命令和job工作流，能够自定义job步骤设置shell命令/job运行周期，可以在任意数量的服务器上批量执行不同的任务，降低对自动化的部署、执行、维护的工作难度。</li>
</ul>


<h2>日常开发</h2>

<p>日常开发指的是一些日常需要掌握的技能、工具等。</p>

<ul>
<li>编辑器：开发中现在用的比较多的编辑器包括Emacs、Vim和SublimeText。笔者用的最多的就是SublimeText，基本能够满足自己的开发需求，包括编写脚本代码、查看代码文件等。Vim和Emacs这两款编辑器相对SublimeText来说需要记住很多命令，有一定的上手门槛。</li>
<li>源码版本管理：代码的版本管理工具由CVS到SVN再到现在的Git，已经在事实上形成了以分布式版本管理为主的版本管理方案。基于Git，可以采用Git Flow做为源码管理模型。</li>
<li>项目工具：Github是一个第三方Git中央仓库，目前是世界最大的开源代码库，也能够做为私人的代码管理软件；Facebook开源的Phabrictor提供了非常强大的任务管理、Bug管理、测试、代码管理等，但其上手门槛相对较高；禅道是国人开发的一款项目管理工具，但是其免费版功能有限；以Tower.im为代表的第三方项目管理服务也是一个可选择的方案，风险在于数据都不再是私有的。</li>
</ul>


<h2>运行环境</h2>

<p>后端应用开发完成之后是需要部署到服务器上对外提供服务的。从最开始的直接在物理机上部署服务到后来的虚拟环境、云环境再到现在火热的容器，直至最近兴起的无服务器技术。都是为了让服务的运行环境能够更加便于建立、更容易维护、更容易扩展。</p>

<ul>
<li>Linux: 说到后端服务器肯定绕不过Linux。至少现在互联网的后端服务绝大多数都是部署在Linux的各种服务器版本中的。其中CentOS、Ubuntu以及Debian是用的比较多的版本。对于Linux，需要熟练掌握的就是很多常用Shell命令如ps、netstat、lsof、ss、df、dh等等。此外，很多性能分析命令如top、vmstat、iostat、sar等也需要熟练使用。</li>
<li>应用服务器：就Java来讲，很多时候开发的都是Web应用，以HTTP协议对外提供服务。除了对性能要求比较苛刻的情况下会自己构建HTTP服务之外，大部分情况是需要依赖于支持Java程序的应用服务器的。目前最为常用的有：Tomcat、Jetty。严格来讲，这两者只是Servlet容器，真正的JavaEE应用服务器如Jboss、Weblogic在互联网领域很少使用。当然，这些软件并没有提供URL重写、请求委托等Web服务器功能，还不足以担当完整Web服务器的角色。Nginx则是目前最为流行的Web服务器。</li>
<li>负载均衡：在高并发流量环境下，后端服务会以集群的模式对外提供服务。在集群的前面，需要负载均衡器将请求分配到集群的各个结点上。LVS是最为流行的四层负载均衡软件,HAProxy是另一个即支持四层又支持七层负载均衡的软件，Nginx则是七层负载均衡最为流行的解决方案。当然，性能最为好的负载均衡方案是以F5为代表的硬件负载均衡，但由于其昂贵的成本因此在互联网团队中很少使用。此外，这里需要补充的是为了保证同等角色的服务的高可用，如LVS经常作为流量的入口，因此会部署多个LVS结点互为主备防止一个挂掉的时候造成服务不可用。而实现互为主备的技术目前用的最多的就是Keepalived。</li>
<li>虚拟化：虚拟化技术是前几年经常用来做私有云的一种技术。即将自己的物理主机通过虚拟化技术分裂为多个虚拟主机，能够隔离资源。其中，VPS（虚拟专用服务器）的代表技术包括：微软的Virtual Server、VMware的ESX Server、SWsoft的Virtuozzo。此外，OpenStack提供的构建私有IIAS的功能、Cloud Foundry提供的构建私有平台运行环境以及Docker、Kunernetes带来的容器服务都是虚拟化技术的一种。</li>
</ul>


<h2>第三方服务</h2>

<p>虽然从根本上讲所有的软件服务都是可以自己开发的或者部署到自己服务器上的。但是受限于成本、周期或者其他客观因素，很多服务还是需要使用第三方的。</p>

<ul>
<li>IAAS：Infrastructure As A Service, 是云计算最开始的一种模式，现在基本上所有的云服务商都有IAAS的服务。其中，全球最强大的云服务提供商是亚马逊的AWS，国内的则当属阿里云。就目前来看，即使是强如AWS也会出现一些运维故障，因此国内的这些云计算提供商很多时候的服务健壮性、运维响应更是经常被人吐糟。就笔者自己的经历来看。2010年左右，盛大云的云服务其实做的还不错，但后来由于种种原因现在基本已经没啥份额了。国内除了阿里云，UCloud算是专注做云计算的一个比较靠谱的公司了。此外，还有一个青云，做的东西略显高大上，也是一个不错的选择。当然，现在这些云服务商早就不仅仅是IAAS了，也做了很多PAAS的服务。</li>
<li>PAAS：Platform As A Service，即只需要提交代码到指定的运行环境，其他的诸如代码打包、部署、IP绑定都由平台完成。除了可以使用Cloud Foundry构建自己的PAAS平台以外，现在最为流行的第三方PAAS服务有：新浪的SAE、百度的BAE以及Google的GAE。</li>
<li>域名：有个可以提供服务的应用后，那么域名也是一个必须的基础设施。一个好的域名不仅仅代表企业的形象，也能够更加方便用户的记忆与传播。目前购买域名可以通过国外的name.com、godaddy以及国内的万网等。有了域名之后下一步就得进行备案，域名提供商一般都提供了配套服务或者去找一些代理也可以办下来。此外，对于域名的解析，域名提供商一般会内置解析功能，也可以使用独立的DNS服务，如dnspod。</li>
<li>CDN: 内容分发网络，即就近请求的一种技术实现。服务提供方将会被大量访问的内容在全国的多个结点都做缓存，这样当用户访问时就能够就近选择，从而减少网络传输延时，提高访问速度。国内目前七牛和又拍都提供了不错的CDN服务，当然像阿里云、UCloud这种综合云服务商也都有CDN服务。</li>
<li>邮件发送：这个主要需要依赖邮件服务器，然后通过SMTP协议就可以实现发送。可以选择自己搭建，也可以选择诸如腾讯邮箱、网易邮箱等。</li>
<li>短信发送：使用短信发送验证码、营销短信是很常见的应用场景。由于短信是需要运营商支持的，所以这一块基本上都是需要依赖第三方代理的。市面上也有很多短信网关代理。</li>
<li>消息推送：在移动应用上，推送已经成为一个标配功能。目前个推应该是第三方推送服务中的佼佼者，而且由于其客户很多，在联盟唤醒上有很大的优势。</li>
<li>开放平台：通过开放平台，可以使用OAuth等协议获取用户在第三方平台上的信息实现第三方平台登录等。目前，微博、微信、QQ是最常见的第三方登录方式，基本上都是使用OAuth协议为第三方开发者提供服务的。</li>
<li>支付接口：支付接口是很多内置购买功能软件的必备组件。目前，接入最多的无非是支付宝和微信，都提供了开放平台供商家接入。当然，也有直接绑定银行卡支付的，此时需要走的就是银行或者银联的网关接口。</li>
</ul>


<h2>计算机基础科学知识</h2>

<p>对于像数据结构、算法、计算机网络、操作系统、计算机组成原理这些计算机科学基础知识，不管是后端还是其他领域都是必须的技能，也是所有软件开发的基础。扎实的计算机科学基础才能让你在学习、使用某种技术开发软件、调试软件、排查问题时能够心里有底、有据可循。</p>

<ul>
<li>数据结构：数据结构是组成程序的基础。经典的数据结构包括：字符串、数组、链表、哈希表、树（二叉树、平衡树、红黑树、B树）、堆栈、队列、图。</li>
<li>算法: 经典的排序和查找算法在平时的开发工作中经常会用到，如：冒泡排序、插入排序、选择排序、归并排序、快速排序、希尔排序、堆排序以及二分查找等。此外，在函数/方法的算法实现中要注意递归和迭代各自的优缺点。而衡量算法性能无外乎空间复杂度和时间复杂度。</li>
<li>业务相关算法：除了上面的基本算法之外，业务中还会经常涉及到一些更为复杂的算法，如：压缩算法、LRU缓存算法、缓存一致性、编译原理中的状态机等。此外，目前越来越火的机器学习中有很多算法也是在很多业务场景中有很大用途的，如：用于文本分词的结巴分词和中科院ICTCLAS；用于关键词提取的TF-IDF和TextRank；用于计算文本相似度的主题模型、Word2Vec、余弦相似度以及欧几里得距离；用于文本分类的朴素贝叶斯；用于推荐的聚类、协同过滤、用户画像、隐语义模型等。</li>
<li>计算机网络： TCP/IP协议是网络最根本的协议，其七层/四层协议栈的设计都是非常精华的东西，连接的建立、断开以及连接的各种状态的转换都是排查、解决网络问题的根本依据。从TCP/IP往上，HTTP协议是现在绝大多数后端应用对外提供的协议，发展到现在已经将要步入HTTP2.0时代，带来了持久连接、连接复用等令人振奋的新特性。此外，基于HTTP的HTTPS协议由于其安全性在逐渐的成为后端服务对外开放的主流协议。业务层面，基于HTTP协议的RESTful规范正成为对外接口的主流规范，而OAuth2.0协议也在成为开放平台对外的主流协议。除了HTTP之外，SMTP是另一个基于TCP/IP的应用协议，主要用在发送邮件上。</li>
<li>设计模式： 在软件开发中，前人的经验形成了很多经典设计模式供我们使用，能够使得软件的实现可服用、可扩展、可维护。经典的工厂模式、简单工厂模式、单例模式、观察者模式、代理模式、建筑者模式、门面模式、适配器模式、装饰器模式在日常的很多开发场景下都具有很重要的意义。</li>
</ul>


<h2>数据</h2>

<p>现在互联网的所有业务其实都是围绕数据来进行的。而数据传输、数据存储、数据分析处理都是关键的部分。</p>

<ul>
<li>高速缓存：目前用的最为广泛的缓存软件Redis能够支持丰富的数据结构，如：字符串、列表、有序集合等多种数据的存储。了解缓存实现的原理、内存淘汰的策略能够更好地使用缓存。此外由于缓存的成本较高，在使用缓存的时候一定要做好量化和存储优化工作。</li>
<li>数据库：掌握数据库的很大一个关键点就在于对索引的使用，可以说，正确地使用索引就基本等于掌握了数据库的使用。目前绝大多数据库都是使用B树做为索引的数据结构，目的就是为了利用磁盘顺序读写的特性。不同的数据库由于本身设计目的的不同，都有一些独特的优势，如：MongoDB天然支持sharding，但受限于NoSQL，在重事务、有关联关系的场景下并不适用；HBase使用LSM作为底层数据结构，牺牲了读性能来换取高速的写性能。</li>
<li>搜索引擎：搜索引擎主要应对全文检索以及多维度查询的业务场景。掌握搜索引擎使用的数据结构、集群方式、配置的关键点有助于更好地使用搜索引擎服务于业务应用。</li>
<li>消息队列：消息队列有两种角色：生产者和消费者，两种角色对于消息队列的需求也不一样。其中，对于消费者来说，消息消费的方式包括发布-订阅和队列两种。消息队列在语义保证上分为：At Most Once、At Least Once、Exactly Once三种模式，需要更具特定的业务场景选择合适的语义保证。此外，消息队列对于高可用、消息安全的保证决定了此消息队列的可靠性。</li>
<li>数据存储和分析：数据存储下来最终还是要用来做分析和处理的。数据的处理分为离线处理和实时处理。离线处理的优势在于能够处理大量数据，但是一般会有T+1的延迟，适用于计算量大但是对于结果允许有延时的场景。但对于离线数据分析，还有一个很关键的就是数据倾斜问题。所谓数据倾斜指的是region数据分布不均，造成有的结点负载很低，而有些却负载很高，从而影响整体的性能。因此，处理好数据倾斜问题对于离线数据处理是很关键的。而实时处理一般是流式处理方式，适用于数据能够转换为数据流，对于结果要求及时性的场景。对于实时数据分析，需要注意的就是实时数据处理结果写入存储的时候，要考虑并发的问题，虽然对于Storm的Bolt程序来说不会有并发的问题，但是写入的存储介质是会面临多任务同时读写的。通常采用的方案就是采用时间窗口的方式对数据做缓冲后批量写入。此外，基于Yarn、Mesos这种资源统一管理调度系统进行数据分析需要根据运行原理的不同进行适当的配置。</li>
<li>数据同步：数据仓库的数据来源除了直接的日志外还有一个很关键的就是业务数据库。从业务数据库到数据仓库的过程称为数据同步。有基于SQL的同步方案，也有基于MySQL binglog的增量同步方案。</li>
</ul>


<h2>Java</h2>

<p>对于Java方面的技能来说，主要有两个大的部分，包括Java编程和JVM。</p>

<p>先来看一下Java编程部分，这也是Java工程师最最基础的技能。</p>

<ul>
<li>IDE: 目前用的最多的Java IDE当属Eclipse和Intellij IDEA。前者是老牌IDE，逐步淘汰了Jbuilder以及Netbeans，占领了大部分Java IDE市场。后者则是后起之秀，由于其增量编译、智能分析代码等带来的性能提升，现在已经得到了大规模使用，大有取代Eclipse之势。</li>
<li>核心语法：目前用的最多的当属JDK6的Java语法。而到了Java7引入了try with resource、switch string、diamonds等语法。Java8则又引入了lambda、stream等语法。</li>
<li>集合类：集合类是Java语言中非常精华的部分，包括：HashMap、ArrayList、LinkedList、HashSet、TreeSet以及线程安全的ConcurrentHashMap、ConcurrentLinkedQueue等线程安全集合。了解他们的实现原理以及查询、修改的性能以及使用场景是非常必要的。</li>
<li>工具类：Google Guava、Apache commons、FastJson提供了很多JDK本身没有的工具类、集合等。此外，ASM字节码操作以及CGLIB代码生成能够提供更底层的java编程功能。</li>
<li>高级特性：抛开Java核心的基本编程，并发编程、泛型、网络编程、序列化RPC都属于java的高级编程特性。其中并发编程需要掌握Executors提供的各种并发工具、Java7带来的fork/join框架以及CountDownLatch、Semaphore、CyclicBarrier等同步工具；网络编程要区分好BIO、NIO以及AIO；序列化中除了JDK自带的序列化实现之外，Protobuf和Kryo是比较高效的第三方实现；RPC的实现中，Thrift、Hessian、Dubbo以及RMI则是比较常用的几个协议,其中的Hessian是基于Http协议的，Dubbo是基于TCP协议，而Thrift则同时支持。</li>
<li>JavaEE: JavaEE现在是Java应用最为普遍的一个领域。Servlet是JavaEE中最根本的组件之一。而Servlet3.0带来的异步Servlet提高了其处理请求的性能。</li>
<li>项目构建：目前用的最多的Java项目构建工具包括Maven和Gradle，提供了源码包依赖管理、编译、打包、部署等一系列功能。</li>
<li>编程框架：Spring是Java编程中避不开的一个框架，发展到现在除了Spring核心的IOC、AOP之外，SpringMVC、Spring Data、Spring Cloud、Spring Boot等等都给Java开发者们带来了开发上的便利，大大提高了开发效率；ORM框架MyBatis也是Java领域比较火的框架之一，实现了数据库记录到Java对象的映射操作；Jersey则提供了从客户端到服务端的一整套符合RESTful规范的开发框架。此外，Vert.x、Spring Flux这种非常适用于IO密集型应用的异步响应式编程框架也开始兴起。</li>
<li>测试：测试是任何编程都需要的一步。黑盒测试主要指的通常进行的功能测试，白盒测试则主要指的对代码功能、质量进行的测试。此外，关键的单元测试则是开发工程师需要着重注意的地方，“测试驱动开发”的理念也是值得推崇的开发方式。JUnit是目前Java中实现单元测试的主流方案。</li>
</ul>


<p>一般来说掌握上面所述的Java编程技能是能够应付大多编程工作的。但是如果在代码层面已经做到最大努力却还是达不到性能要求的时候，就需要在JVM虚拟机层面做一些努力了。可以说掌握JVM相关技术是Java开发进阶的一个关键步骤。</p>

<ul>
<li>虚拟机实现: Java的虚拟机实现除了我们常用的HotSpot外，还有JRockit、J9以及移动平台的Dalvkit、ART（Android4.4后引入）。我们通常锁描述的JVM优化绝大多是是针对HotSpot虚拟机来说的。</li>
<li>类加载机制：JVM的类加载机器遵循双亲委派原则，即当前类加载器需要先去请求父加载器去加载当前类，如果无法完成自己才去尝试进行加载。OSGI框架则打破了此机制，采用了平等的、网状的类加载机制，以实现模块化的加载方案。</li>
<li>运行时内存组成: 程序计数器、堆栈、方法区、堆、堆外内存，这些一起组成了JVM的运行时内存。</li>
<li>Java内存模型：Java的主内存+线程私有内存的模型是线程安全问题产生的根本。</li>
<li>GC原理和调优：与C、C++这些语言相比，GC是Java的优势，但因为GC的细节被JVM屏蔽了，在对内存、性能要求非常苛刻的情况下难以进行自由控制，某种程度这也是劣势。如果想在某些场景下发挥GC的最大性能，能做的就是对GC的各种参数做优化配置，如新生代和老年代的垃圾回收器选择、各种垃圾回收参数的配置等。此外，很多时候由于代码质量或者外部客观因素，造成了JVM频繁GC，需要使用相关的工具快速进行问题定位和解决。</li>
<li>性能调优和监控工具：JDK自带了很多强大的调优和监控工具，包括jmap、jstack、jcmd、jconsole、jinfo等。此外，btrace是一款非常强大的在线问题动态排查工具，能够无须重启Java进程，动态的插入一些代码逻辑，从而拦截代码执行逻辑打印日志，从而排查问题。</li>
</ul>


<h2>系统架构</h2>

<p>一个应用从0开始一般会经历单体应用、垂直应用到分布式服务架构的演化（具体的会随着业务的不同有所不同）。如下图所示：</p>

<p><img src="//post_images/javatech/arch.png" alt="" /></p>

<ul>
<li>单体应用：当应用规模、团队规模比较小的时候，只需要一个包括了所有功能的应用即可。减少部署结点，也减少了部署成本。此时，对数据库的ORM操作是架构实现的关键点。</li>
<li>垂直应用：当应用的用户规模越来越大，请求量越来越高的时候。单体应用增加结点带来的资源浪费会凸现出来，因为绝大多数接口请求量并没有特别大，根本没必要扩充到多个结点。此时，就可以将单体应用拆分成互不相关的几个应用，分别对外提供服务。此时，加速每个应用开发的MVC框架是架构实现的关键点。</li>
<li>分布式服务：当垂直应用越来越多，应用之间的交互不可避免。抽离核心业务单独部署，逐渐形成稳定的服务中心。而随着团队规模的相应扩大，服务会随着团队的增多变得越来越多，粒度也会变得越来越小,也就逐步形成了分布式服务的架构，而当粒度细到某种程度、服务数量多到一定程度则可以称之为微服务。即在设计好业务边界之后将原来的单体应用分解成一个个细粒度的服务，彼此之间通过某种方式进行通信。微服务架构的关键在于如何做好服务的治理、调度、维护工作。目前，Dubbo算是微服务架构中用的比较多的框架，但Dubbo仅仅解决了微服务架构中的一部分问题。Spring Cloud则基本上涵盖了微服务架构的各个方面。</li>
</ul>


<h2>部署架构</h2>

<p>对于Web应用来说，LVS+Nginx+Tomcat+MySQL+Redis即可构成一个简单通用的部署架构，如下图所示：</p>

<p><img src="//post_images/javatech/web-arch.png" alt="" /></p>

<ul>
<li>LVS作为最前置的结点，负责在网络第四层转发流量、负载均衡。</li>
<li>多个LVS使用Keepalived互为主备实现高可用。</li>
<li>Nginx作为反向代理，负责在网络第七层转发流量、负载均衡。此外，其做为高性能Web服务器，还可以负责静态页面/资源的访问。也可以通过Nginx lua应对一些高并发的动态场景。</li>
<li>Tomcat做为业务容器，主要的应用代码都在这里面。</li>
<li>Redis作为缓存，隔离高并发请求和后端数据库。</li>
<li>MySQL以主从模式对数据做持久化。</li>
</ul>


<p>其中，虚线部分是数据库层，采用的是主从模式。也可以使用Redis Cluster（Codis等）以及MySQL Cluster（Cobar等）来替换。</p>

<blockquote><p>本文节选自《Java工程师修炼之道》一书。</p></blockquote>

<p><img src="http://www.rowkey.me/post_images/book-all.png" width="400"/></p>
]]></content>
  </entry>
  
</feed>
