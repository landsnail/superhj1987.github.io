<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: misc | 后端技术杂谈 | 飒然Hang]]></title>
  <link href="http://www.rowkey.me/blog/categories/misc/atom.xml" rel="self"/>
  <link href="http://www.rowkey.me/"/>
  <updated>2019-04-13T16:36:08+00:00</updated>
  <id>http://www.rowkey.me/</id>
  <author>
    <name><![CDATA[飒然Hang]]></name>
    <email><![CDATA[superhj1987@126.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我的2018]]></title>
    <link href="http://www.rowkey.me/blog/2019/01/26/my2018/"/>
    <updated>2019-01-26T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2019/01/26/my2018</id>
    <content type="html"><![CDATA[<p>此文是我在部门内的一次公开信（经过脱敏），想法来自于《原则》和《谷歌是如何运营公司的》两本书。极度求真、 极度透明的原则是一个想要做出大事业的公司应该具有的气度，而对所有同事能够客观地陈述自己的得与失，并欢迎吐槽，这不仅仅是真诚文化、极度透明原则的体现，也是对自己的一种压力和驱动。</p>

<!--more-->


<hr />

<p>hi, 技术平台部的各位同学：</p>

<p>2018年，我们优化升级了我们的大数据基础设施、运维平台以及推荐引擎，保障了业务的稳步前进；进一步发挥了数据分析师的作用，为业务和商业的发展指明了方向；上线了广告DSP平台，加速了公司的商业变现&hellip;虽然期间出现了一些事故，但总体上还是受到了其他部门的一致好评。感谢大家一年的努力，让我们技术平台部发挥了该有的”平台“作用。希望大家在新的一年继续加油，贯彻“平台”理念，为业务发展提供强有力的保障。</p>

<p>之前安排了大家做每个人和每个团队2018年的工作总结和2019年的工作规划。看到大部分人都能认识到过去的一年自己的问题，也能做好新的一年的规划。现在我把自己的总结规划分享给你们，希望能给你们一些启发。当然，如果有我自己没觉察到的我自身存在的问题，欢迎私信给我。</p>

<p>自己今年的工作可以从四个大方面来讲：部门管理、技术委员会、架构、数据挖掘。</p>

<h3>部门管理</h3>

<p>2018年自己有了新的角色定位，需要对公司的整个技术团队负责，这也让18年成为了自己写代码最少的一年，也是让自己决心进行角色转变的一年。虽然之前也在对整个后端团队以及部门（平台事业部->后台技术中心->技术平台部）做管理工作，但对自己来说，很长一段时间心里对管理是排斥的，尤其是当管理杂事越来越多，写代码的时间越来越少。自己的性格也是属于偏情绪化的，很多时候会让潜意识占了上风，说一些错误的话，发一些没必要发的脾气。在之前的管理工作中，自己意识到管理的并不好，一直还处于研发工程师的角色上。这在18年开始自己就进行了刻意的改变，试着跳出工程师思维，多从团队整体考虑问题，多从对方角度看待问题。具体的事情包括：</p>

<ul>
<li>优化月度考核机制，强调考核的具体原则以及从团队角度进行评估的视角。最终形成了主管和员工两条线、优秀员工投票选举、优秀主管负责人指定的月度考核机制。</li>
<li>加强一对一沟通，建立反馈问题的模式。</li>
<li>确立部门月会&amp;&amp;Leader周会的会议机制。</li>
<li>建立部门的操作手册让流程公开透明，提高做事效率。</li>
<li>带领大家学习并切实的开始实践OKR。建立部门的OKR流程，做到季度末部门月度会议复盘上一季度OKR、制定下一季度OKR。</li>
<li>强调“件件有着落，事事有回音”的团队文化，旨在解决很多人对交待的任务不主动响应、不主动汇报进度的非职业素养问题。</li>
</ul>


<p>此外，年初新业务的突击上线自己担任了项目管理和架构师的角色，后续自己也花了一些时间协助业务部门定位排查故障。日常的简历筛选、面试也占用不少时间和精力。</p>

<p>在年度考核中，看到同事们对自己的一些意见，基本都符合我的自我认知，也是在管理方面自己需要改进的：</p>

<ul>
<li>说服力：有些时候会比较急，语气比较强烈，因此会让人有抵触的情绪，需要进一步提高自己的沟通技巧和说服力。此外，有时候并没有了解事情的来龙去脉就下结论，这个需要竭力避免自己的主观臆断。</li>
<li>应变能力：转变为管理角色后，需要培养自己之前很抵触的审时度势、待人处事灵活的特质。</li>
<li>激励团队：目前对团队的激励的方式包括团队聚餐、项目奖励、月度奖励、技术书籍奖励等，并没有其他更加有效的激励措施。这一点需要改进，多想一些赋能方式来激励团队。</li>
<li>协作：和说服力那一点一样，在协作时有时候会太急，用职权影响力或者情绪化来影响结果。这个都是自己没有很好转变角色的问题。</li>
<li>高估团队：这个的本质问题还是观念改变，需要自己认识到目前团队成员的状况，对不同的人采取不同的领导策略，不能全部是放养状态，做好辅导和问题预估的协助。</li>
</ul>


<h3>技术委员会</h3>

<p>公司的技术委员会已经成立了三年，其一开始是为了评选“技术创新奖励”，后来随着公司的组织架构调整为按照业务为单位的敏捷式组织，技术委员会的横向管理职责越来越大。2018年限于业务迭代压力的问题，技术委员会的运行并没有走上正轨，但也做出了一些产出：</p>

<ul>
<li>确立了技术分享机制，大前端和后端都进行了系列分享。</li>
<li>制定了各个研发职位的能力模型，让技术团队成员都能够对自己的职业发展有清晰的认识。</li>
<li>完善了研发职位的学习计划，给入门的工程师提供学习指导。</li>
<li>制定了事故制度和研发高压线，规范事故处理流程，明确不可触碰的高压线。</li>
<li>制定技术选型原则，给技术团队做技术选型的指导。</li>
<li>制定实习生培养制度，规范化实习生转正流程。</li>
<li>进行“Hold住前后端系列分享”，提高资深以上工程师整体技术把控能力</li>
<li>带领各个技术Leader做了《技术管理实战三十六讲》的学习和沟通，解惑了很多程序员在转型管理时候面对的问题，让大家对“管理”有了更明确的认知。</li>
<li>例行的技术周刊、技术创新奖励继续得到有效执行。</li>
</ul>


<h3>架构</h3>

<p>架构方面，产出了一些公共组件和规范：</p>

<ul>
<li>制定了技术评审机制，强调对容器、中间件的容量预估和限流，从架构设计开始尽量规避性能故障。</li>
<li>梳理架构隐患分析流程，强调对架构的隐患分析和预防。</li>
<li>梳理系统稳定性原则，给系统设计时的稳定性予以指导。</li>
<li>制定架构设计文档模板：技术调研、技术方案分析、系统设计，规范系统设计流程。</li>
<li>研发公共组件：antares分布式调度中心。</li>
</ul>


<p>由于业务增长给后端带来了很大压力，在年底筹划并成立了架构组，由各个后端Leader组成，是一个虚拟的横向组织。其主要负责公司的架构规范梳理和制定以及公共组件/中间件的开发。目前基本上囊括了自己进入公司以来做的一些公共组件开发和架构规范工作，最近也产出了公共组件搜索平台供研发人员使用。</p>

<p>此外，为了进一步提高各个Leader的架构能力，给大家购买了极客时间《从0开始学架构》课程并组织了学习讨论会，在去年进行过一次架构学习的基础上再一次让大家讨论了对架构的认识和理解。并且做了《浅析区块链》、《后端基础设施》、《架构设计与原则》、《如何排查在线故障》的分享，提高大家的架构、故障排查等能力。</p>

<h3>数据挖掘</h3>

<p>数据挖掘这一方面，由于客观原因，自己一直在跟进。年初给自己定的目标是成为一个合格的机器学习调参工程师，能够熟知、理解和实现常用的机器学习算法。这一年也一直在看《机器学习》西瓜书、《机器学习实战》两本书。不过由于各种杂事以及架构工作的干扰，进度一直很慢。虽然最终阅读完了《机器学习实战》这本书，也实现了大部分算法，但数据挖掘有了更加合适的人来做具体工作，基本能Hold住目前的需求，自己也没有那么多时间专注这一块，在权衡了收益之后（把精力放在架构上给团队带来的收益会更大），最后决定放弃。毕竟，数据挖掘这一块入门需要花大量的时间来补充大量知识。如果没有那么多的时间专注做这件事情，入门都难，更难谈熟悉和精通。</p>

<p>所以，这一年参与了很小一部分推荐系统的开发工作，大部分是在担任推荐引擎的项目管理工作。本年度推荐系统最大的一个改进是做了架构的升级，引入了召回+CTR预估的推荐机制，合理划分了推荐引擎的分层架构。</p>

<h3>学习</h3>

<p>学习方面，平时会零零散散看一些微信和博客上的文章，并把其中自己觉得受到启发的点经过验证后纳入到自己的知识体系文档中。此外，自己今年包括在线课程一共学习了14本书/课程。如下：</p>

<ul>
<li><p>OKR: 源于英特尔和谷歌的目标管理利器</p>

<blockquote><p>此书是公司管理层进行统一学习的一本书，不厚，花了三个晚上大约6个小时就读完了。主要是对OKR这种目标管理方法的入门指导。不同于绩效的，OKR强调的是自驱力和挑战性，并不用来考核，是为了识别高绩效员工。O表示Objective，KR表示Key result。把周期内的事务分解为一个个目标，再把完成这个目标的衡量标准分解为一个个关键结果。周期结束复盘关键结果的完成度，也就相当于复盘了目标的完成度。</p></blockquote></li>
<li><p>尽在双11，阿里巴巴技术演进与超越</p>

<blockquote><p>此书讲述的是阿里巴巴为了支撑双十一技术上的一些演化。包括大数据平台、机器学习平台、数据中间件、容量规划、全链路压测、系统稳定性保障、流控方案、协同运维、移动端混合开发等技术。能够看到架构和技术是随着业务的发展而不断演进的，能够给我们这种小公司一个未来技术规划的路线图。</p></blockquote></li>
<li><p>深入分布式缓存</p>

<blockquote><p>集结各大公司技术网红的一本主要讲分布式缓存的书籍。包括缓存和分布式理论、Ehcache和Guava Cache本地缓存框架、Memcached、Redis、Tair、Evcache、Aerospike等集中式缓存，并讲述了这些技术在各大公司的实际应用案例。对自己最有启发的是此书对CAP的讲解，发现自己之前对这个理论的理解貌似有点偏差，就把相关的英文论文又看了几遍。此外，有一章讲述社交场景架构进化，虽然个别指标数字的来源比较模糊也没有说明，但是从数据库到缓存的设计和演进思路确实让我眼前一亮，比如通过前缀+保序压缩设计主键来使用覆盖索引。还值得一提的是在这里第一次看到了Aerospike在广告场景的使用，这个现在已经在我们公司的广告平台进行了实践并取得了较好的效果。</p></blockquote></li>
<li><p>增长黑客</p>

<blockquote><p>一本前几年非常火的书。也是这本书把“增长黑客”的概念引入国内。讲述了什么是增长黑客、增长在做什么、如何做增长等内容。由于工作中与增长并不密切相关，因此感触并不多。算是自己在增长方面的一个入门读物。</p></blockquote></li>
<li><p>Microservices AntiPatterns and Pitfalls</p>

<blockquote><p>微服务的反模式和陷阱。是O’Reilly的免费电子书，主要讲述了在做微服务设计和实现的时候经常会做错的一些事情。强烈推荐想要做微服务的同学看一下此书。我自己的翻译见：<a href="http://www.rowkey.me/blog/2018/06/02/microservice-pitfall/">http://www.rowkey.me/blog/2018/06/02/microservice-pitfall/</a>。</p></blockquote></li>
<li><p>Reactive Microservices Architecture</p>

<blockquote><p>响应式微服务架构-分布式系统设计原则。同样是O’Reilly的免费电子书，主要讲述了在做微服务设计的时候需要遵循的原则。结合上面的微服务的反模式和陷阱，能够更好地认识、设计和实现微服务。我自己的翻译见：<a href="http://www.rowkey.me/blog/2018/06/07/reactive-microservice/">http://www.rowkey.me/blog/2018/06/07/reactive-microservice/</a></p></blockquote></li>
<li><p>进化-运维技术变革与实践探索</p>

<blockquote><p>来自极客时间相关课程的一个书籍。主要讲述了运维技术的演进和实践。其中让我自己印象比较深的，一个地方是其讲述的架构师负责设计架构，运维则是负责管理架构；另一个地方是美丽说实践的一个办公室测试环境（小蘑菇环境），这个我们公司后来也进行了实践和推行。此外，这本书给出的事故定则维度和研发高压线也给了自己一些启发，进一步出台了公司的相关制度。</p></blockquote></li>
<li><p>推荐系统三十六计</p>

<blockquote><p>极客时间的一个课程。讲述的业界推荐系统主流的一些做法，包括各种召回策略/算法、融合排序方案、EE问题解决方案等，基本能够解决推荐系统80%的问题。此书给了自己不少启发，后续公司的推荐引擎的架构升级和团队规划的想法就来源于此。</p></blockquote></li>
<li><p>码农翻身</p>

<blockquote><p>花了差不多四个晚上大约4个小时阅读完此书。全书基本都是些基础知识，收获有一点（巩固了一些自己之前似是而非的点，比如Java动态代理为什么不能代理没有实现接口的类），但确实不太多。不过这种用故事讲技术的方式的确让自己有了一些启发，很多时候能够把技术和现实联系起来，既能够加深自己的理解，也能够更容易给别人讲明白。而最后作者给出的程序员需要<strong>克服内向心里，凡事必先上虎背</strong>，这个自己非常认同，人很多时候不逼自己一把是不知道自己有多少实力的。</p></blockquote></li>
<li><p>原则</p>

<blockquote><p>今年非常火的一本书，是桥水的创始人对自己生活以及工作的原则所做的总结。其中最让我印象深刻也注意后续实践的包括：头脑极度开放、极度求真和极度透明。第一点让自己突破了心里的一个坎，认识到人都有自我意识和思维盲点，会经常审视自己是否不敢接受自己在某些方面的欠缺，是否能够以开放的心态聆听别人的意见和看法，讨论问题时是否是抱着解决问题而不是论证自己的观点的态度。后面两点在公司里其实很难实现，但一旦实现，换来的是全员的目标一致、利益一致，随之而来的会是高效地产出。这个也是后续自己要在部门坚定推行的一种文化。此外，也注意到在评估一个工作业绩不突出的同事时要区分是其能力（包括学习能力）不够还是经验不够。经验不够可以学习弥补，但如果是能力不够则需要考虑淘汰。</p></blockquote></li>
<li><p>从0开始学架构</p>

<blockquote><p>来自极客时间的专栏课程，是对架构的一个入门讲解。其中的很多知识点都印证了自己之前的一些总结和实践。让自己受用的主要是其提供的几个架构设计文档模板：技术方案设计、技术方案评估和选择、详细方案设计。</p></blockquote></li>
<li><p>技术管理实战36讲</p>

<blockquote><p>同样是来自极客时间的专栏课程，给公司的所有技术Leader都购买并进行了学习讨论。主要就是解惑技术转管理面对的那些问题。如技术人的职业后期的方向有哪些？技术人适合做管理吗？管理到底做什么？管理能够成为自己的立身之本吗？其阐述的管理就是“看方向”、“带人”、“做事”，非常接地气的阐述了管理的职责。从公司几个技术Leader的反应来看，都觉得很受启发，尤其是角色认知这方面。相比起其他管理方法论，这个更加联系实际，更加干货。其讲述的团队规划方案、驱动力3.0等后来也运用在了实际工作中。</p></blockquote></li>
<li><p>机器学习实战</p>

<blockquote><p>这本书是入门机器学习的经典书籍之一，结合代码和原理讲解常用的机器学习算法。基本涵盖了机器学习常用的分类、预测、聚类、频繁项发现等算法。结合《机器学习》西瓜书，理论+实践，是入门机器学习的推荐方式。</p></blockquote></li>
<li><p>重新定义公司：谷歌是如何运营的</p>

<blockquote><p>这本书是在去参加年会的路上看完的，也就3个小时左右。主要讲述了Google特色的运营公司的方法。当然，Google能那么做并不代表你也可以这么做，毕竟人才的素养差距有点大。其中让自己感到受用的有两方面：会议的决策者应该亲力亲为，从通知议程、会议召开、保证质量、设立目标、确定与会人员到会议纪要都要亲自执行；要做好职业规划，想象自己五年后希望的职业，那个职位的JD是什么样子的，要求如何?并对照看自己的优势/劣势在哪，怎么去改进。</p></blockquote></li>
</ul>


<p>以上书籍/课程的学习笔记我都放在了Github(<a href="https://github.com/superhj1987/ToDo/issues/1">https://github.com/superhj1987/ToDo/issues/1</a>)上，通过issue的方式串联起来，确实提高了记录笔记的速度和学习的有效性。不过最近发现使用幕布（<a href="https://mubu.com">https://mubu.com</a>）这个软件思维导图的方式更加合适做学习笔记，也正在转移到这上面。当然，像marginnote则是更为强大的阅读笔记软件，感兴趣的可以使用。这里要再强调一下的是做读书笔记的重要性，之前有朋友特别喜欢购买书籍，书架上全是，咋看之下，绝对是啥都懂的超级大神，但其实大部分书都没有翻过，翻过的也基本看完就放在那里了。这样如果看书不注意记录笔记和学习心得并纳入到自己的知识体系中，效果是大打折扣的，尤其是当这本书的知识点和你实际的工作联系并不紧密时，很快你就会就把这本书讲的东西给忘了。我一直以来的做法是看书的过程会通过拍照、文字等形式记录笔记，并在完成阅读后，再概览一遍书的目录，把其中觉得有用的点都纳入到我的知识体系文档中。这样即使后来由于不经常使用而淡忘了也能够快速定位到相关的知识点。</p>

<p>18年也有一些计划的书并没有完成阅读，都纳入到了19年的学习计划中。目前计划的读书列表如下：</p>

<ul>
<li>Clean Architecture</li>
<li>分布式系统概念与设计</li>
<li>复杂</li>
<li>清教徒的礼物</li>
</ul>


<h3>工作之外</h3>

<p>工作之外，自己把2015年就有初步构想的书给出了，最近也收到了编辑寄来的2018年度优秀作者的奖杯。由于书的类型还算新颖，所以结果还不错，但自己其实挺遗憾的。出版前review了很多次，还是在出版后发现了不少错误，甚至一些自己怎么都想不明白为何会犯的错误。这也警醒了自己，不管东西多大多小，只要是输出的东西，务必保证准确性，不求能帮助所有人，但一定也不至于误导别人。与之关联的，自己也一直跟公司的技术团队强调，对于市面上的资料一定要学会甄别，国内的文章、书籍很多都是不可靠的，很多知识点都是copy来copy去，并没有经过作者亲自求证。如果要学习知识，最好的资料就是官方文档，之后是相关的英文书籍或者其权威翻译版本。毕竟，总是去看别人嚼过的知识，那么也就意味着你一直在follow别人，而无法获取技术的第一手资料，也就无法站在技术的前沿。计算机领域绝大多数第一手资料都是英文的，这造成了很多人觉得难以阅读而去看各种中文资料。一个外国朋友更是表达了他对中国技术人员的一个直观的印象就是英文不好，从来不看英文文档或者看的不够仔细，直接导致对技术的运用会有很大的偏差。他说的的确是中国大部分程序员的现状，但我真心不希望我们的技术团队是这样的一个团队，希望大家能够多强迫自己阅读并理解各种英文文档、英文书籍，久了自然而然就会越来越顺手，理解起来也就会越来越容易。</p>

<p>个人生活方面，最主要的还是一直以来的入睡困难、睡眠质量差的问题在困扰自己，导致自己很晚才能入睡，进一步导致自己无法早起，也就让自己失去了很多可以学习工作的时间，想想会觉得很难受。曾经想过很多办法，都效果不大。从8月份开始决定通过健身来彻底改变这些问题，最近也开始注意饮食，希望不久能够从根本上解决这个困扰自己多年的问题，给自己带来更多的学习、生活、工作时间。这里也想跟大家强调一下身体的重要性，任何东西都是以身体为基础的，身体如果不能够健健康康，那么其他的都无从谈起，所以一定要注意锻炼身体从而保证充足的活力和健康。此外，虽然公司给咱们买了保险，还是建议大家都给自己补充一些商业保险，这个其实也是理财的一种形式，用不上最好，一旦用上真的是解决大问题。</p>

<h3>总结</h3>

<p>以上是自己对2018的工作生活的总结，对照18年初的计划基本都达成了，自己大体也是满意的。对于其中各个方面的不足，新的一年也会采取措施来改善。对于2019年的规划，大体如下：</p>

<ol>
<li>加强技术委员会的横向管理作用，全面提升各个技术方向的研发实力。</li>
<li>采取更多更有效的方式提升各个技术Leader的技术管理以及架构能力。</li>
<li>把控架构组的日常工作和组件研发。</li>
<li>做好蜂巢推荐引擎的进一步推进工作，争取能够有突破性的进展。</li>
<li>完善各个团队的梯队建设。</li>
<li>进一步明确自己的角色定位，改善自己的沟通能力和管理能力。</li>
<li>每周做至少2-3道leetcode medium题目，保持自己的编程感觉。</li>
<li>改善自己的睡眠问题和身体状况，提高自己的活力，能够有更多的时间在工作、学习和生活上。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[正则表达式简明指南]]></title>
    <link href="http://www.rowkey.me/blog/2018/03/10/regx/"/>
    <updated>2018-03-10T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2018/03/10/regx</id>
    <content type="html"><![CDATA[<p>公司使用的markdown解析类库一直有一些解析上的问题，最近给fix了。而markdown解析主要是对正则表达式的使用。中间恶补了一下相关知识，在此梳理一下。</p>

<h2>什么是正则表达式</h2>

<p>正则表达式就是用一个“字符串”来描述一个特征，然后去验证另一个“字符串”是否符合这个特征。简单的一个例子：用字符串&#8221;a&#8221;来验证字符串s是否是&#8221;a&#8221;，形如s.match(&ldquo;a&rdquo;)。概括来说有以下作用：</p>

<ul>
<li>验证字符串是否符合指定特征，比如验证是否是合法的邮件地址。</li>
<li>查找字符串，从一个长的文本中查找符合指定特征的字符串，比查找固定字符串更加灵活。</li>
<li>替换字符串，比普通的基于字符串的替换更灵活。</li>
</ul>


<!--more-->


<h2>基本规则</h2>

<h3>普通字符</h3>

<p>字母、数字、汉字、下划线、以及后续没有特殊定义的标点符号，都是&#8221;普通字符&#8221;。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。如：表达式 &ldquo;a&#8221;，在匹配字符串 &#8220;abcde&rdquo;             时，匹配到的内容是：&#8221;a&#8221;。</p>

<h3>转义字符</h3>

<p>一些不便书写的字符，采用在前面加 &ldquo;\&rdquo; 的方法。常见的如：</p>

<ul>
<li>\r: 回车</li>
<li>\n: 换行符</li>
<li>\t: 制表符</li>
<li>&#92;\: &ldquo;\&rdquo; 本身</li>
</ul>


<p>此外，还有其他再正则中有特殊用处的标点符号，在前面加 &ldquo;&#92;&#8221;后，代表该符号本身。如：^, $。如果要想匹配字符串中 &rdquo;^&ldquo; 和 &rdquo;$&ldquo; 字符，需要写成 &rdquo;\^&ldquo; 和 &rdquo;\$&ldquo;。如</p>

<ul>
<li>\^: 匹配^符号本身</li>
<li>\$: 匹配$符号本身</li>
<li>&#92;.: 匹配小数点.本身</li>
</ul>


<p>其匹配规则和普通字符串是一样的，如&#8221;\^&ldquo;匹配&#8221;a^bc&#8221;中的&rdquo;^&ldquo;。</p>

<h3>&lsquo;多种字符&#8217;匹配</h3>

<ul>
<li>\d：任意一个数字，0~9 中的任意一个</li>
<li>\w：任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个</li>
<li>\s：包括空格、制表符、换页符等空白字符的其中任意一个</li>
<li>.：小数点可以匹配除了换行符以外的任意一个字符</li>
</ul>


<p>如：表达式 &ldquo;\dtest\d&#8221;匹配&#8221;1test2&#8221;。</p>

<p>除了正则自带的&#8217;多种字符&#8217;匹配外，还可以通过中括号[]来自定义。</p>

<ul>
<li>使用[ ]包含一系列字符，能够匹配其中任意一个字符。</li>
<li>用 [^ ]包含一系列字符，则能够匹配其中字符之外的任意一个字符。</li>
</ul>


<p>如：[123]匹配 &ldquo;1&#8221;或&#8221;2&#8221;或&#8221;3&rdquo;;[^abc]匹配 &ldquo;a&#8221;、&#8221;b&#8221;、&#8221;c&rdquo; 之外的任意一个字符</p>

<p>这里需要注意的是，在使用[]时，只有会改变字符组含义的才需要转义，</p>

<ul>
<li>反斜线必须转义</li>
<li>方括号必须转义</li>
<li>「^」在首和「-」在中必须转义</li>
</ul>


<p>其他情况即使是特殊字符也不需要转义，如：</p>

<ul>
<li>[aeiou]</li>
<li>[$.*+?{}()|]</li>
<li>[abc^123-]</li>
</ul>


<h3>匹配次数</h3>

<p>&ldquo;次数修饰&#8221;放在&#8221;被修饰的正则表达式&#8221;后边，可以匹配多次。如：</p>

<ul>
<li>{n}: 表达式重复n次，比如： &ldquo;\d{2}&rdquo; 相当于 &ldquo;\d\d&#8221;。</li>
<li>{m,n}:表达式至少重复m次，最多重复n次，比如： &ldquo;a{1,3}&#8221;可以匹配 &#8220;a&#8221;或&#8221;aa&#8221;或&#8221;aaa&#8221;。</li>
<li>{m,}: 表达式至少重复m次，比如： &ldquo;\d{2,}&#8221;可以匹配               &#8220;12&rdquo;,&ldquo;123&rdquo;,&ldquo;12345678&#8221;。</li>
<li>?: 匹配表达式0次或者1次，相当于 {0,1}，比如： &ldquo;a[b]?&#8221;可以匹配&#8221;a&rdquo;,&ldquo;ab&#8221;。</li>
<li>+: 表达式至少出现1次，相当于 {1,}，比如： &ldquo;a+&#8221;可以匹配&#8221;a&rdquo;,&ldquo;aa&rdquo;,&ldquo;aaa&#8221;。</li>
<li>*: 表达式不出现或出现任意次，相当于 {0,}，比如：&#8221;ab*&ldquo;可以匹配                 &#8220;a&#8221;、&#8221;ab&#8221;、&#8221;abb&#8221;。</li>
</ul>


<h3>特殊符号</h3>

<ul>
<li>^: 与字符串开始的地方匹配，不匹配任何字符,这里如果使用(?m)模式，则匹配每一行的开始。如：&#8221;^aaa&#8221;无法匹配 &ldquo;xxxaaaxxx&#8221;，可以匹配&#8221;aaaxxx&#8221;。</li>
<li>$: 与字符串结束的地方匹配，不匹配任何字符，这里如果使用(?m)模式，则匹配每一行的结束。如：&#8221;aaa$&ldquo;无法匹配&#8221;xxxaaaxxx&rdquo;, 可以匹配&#8221;xxxaaa&#8221;。</li>
<li>\b：匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符。它与 &ldquo;^&#8221;、&rdquo;$&ldquo; 类似，本身不匹配任何字符，但是它要求它在匹配结果中所处位置的左右两边，其中一边是 &rdquo;\w&#8221; 范围，另一边是             非&#8221;\w&#8221; 的范围。。如：&#8221;.\b.&ldquo;匹配&rdquo;@@abc&#8221;的&#8221;@a&#8221;。</li>
</ul>


<p>此外，还有一些符号可以影响表达式内部的子表达式之间的关系：</p>

<ul>
<li>|: 左右两边表达式之间&#8221;或&#8221;关系，匹配左边或者右边。</li>
<li>(): 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰;取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到。如：&#8221;(ab\s*)+&ldquo;匹配&#8221;hi, ab ab ab&#8221;中的&#8221;ab ab ab&#8221;。</li>
</ul>


<h2>高级规则</h2>

<h3>贪婪与非贪婪匹配</h3>

<p>在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如：&#8221;{m,n}&ldquo;, &rdquo;{m,}&ldquo;, &rdquo;?&ldquo;, &rdquo;*&ldquo;, &rdquo;+&ldquo;，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，文本 &#8220;axxxaxxxa&#8221;，&rdquo;(a)(\w+)&ldquo;，其中&rdquo;\w+&ldquo;会匹配&#8221;xxxaxxxa&#8221;，&rdquo;(a)(\w+)(a)&ldquo;则会匹配&#8221;xxxaxxx&#8221;。由此可见，&rdquo;\w+&ldquo; 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 &#8220;a&#8221;，但那也是为了让整个表达式能够匹配成功。同样的，带 &rdquo;*&ldquo; 和 &rdquo;{m,n}&ldquo; 的表达式都是尽可能地多匹配，带 &rdquo;?&ldquo; 的表达式在可匹配可不匹配的时候，也是尽可能的<strong>匹配</strong>。这种匹配原则就叫作&#8221;贪婪&#8221;模式。</p>

<p>非贪婪模式则是指的<strong>在修饰匹配次数的特殊符号后再加上一个 &ldquo;?&rdquo; 号</strong>，可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的<strong>不匹配</strong>。这种匹配原则也叫作 &ldquo;勉强&rdquo; 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。如，文本 &ldquo;axxxaxxxa&rdquo; ，&#8221;(a)(\w+?)&ldquo;，其中&rdquo;\w+&ldquo;只会匹配一个&#8221;x&#8221;。</p>

<h3>反向引用</h3>

<p>表达式在匹配时，表达式引擎会将小括号 &ldquo;()&rdquo; 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。如：&#8221;&lt;div>(.*?)&lt;/div>&ldquo;即获取div标签内部的内容。</p>

<p>这里小括号包含的正则表达式所匹配到的字符串不仅仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面括号内的子匹配已经匹配到的字符串。引用方法是 &ldquo;\&rdquo; 加上一个数字。&#8221;\1&#8221; 引用第1对括号内匹配到的字符串，&#8221;\2&#8221; 引用第2对括号内匹配到的字符串，以此类推，而如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 &ldquo;(&rdquo; 在前，那这一对就先排序号。</p>

<p>例如：表达式 &ldquo;(&lsquo;|&rdquo;)(.*?)(\1)&ldquo; 在匹配 &rdquo; &#8216;Hello&rsquo;, &ldquo;World&rdquo; &ldquo; 时，匹配结果是：成功；匹配到的内容是：&rdquo; &lsquo;Hello&rsquo; &ldquo;。再次匹配下一个时，可以匹配到 &rdquo; &ldquo;World&rdquo; &ldquo;。</p>

<h3>预搜索</h3>

<p>如前面所讲&#8221;^&ldquo;、&rdquo;$&ldquo;、&rdquo;\b&#8221;字符有一个共同点，就是：它们本身不匹配任何字符，只是对 &ldquo;字符串的两头&rdquo; 或者 &ldquo;字符之间的缝隙&rdquo; 附加了一个条件。同样的，正则中提供了其他基于此原理的机制，来实现预搜索。</p>

<ul>
<li><p>正向预搜索：&#8221;(?=xxxxx)&ldquo;，&rdquo;(?!xxxxx)&#8221;</p>

<p>  格式：&#8221;(?=xxxxx)&ldquo;，在被匹配的字符串中，它对所处的 &#8220;缝隙&rdquo; 或者 &ldquo;两头&rdquo; 附加的条件是：所在缝隙的右侧，必须能够匹配上xxxxx这部分的表达式，不影响后边的表达式去真正匹配这个缝隙之后的字符。如： &ldquo;Mac (?=book|air)&rdquo; 在匹配 &ldquo;Mac pro, Mac air&rdquo; 时，将只匹配 &ldquo;Mac air&rdquo; 中的 &ldquo;Mac&#8221;。</p>

<p>  格式：&#8221;(?!xxxxx)&ldquo;，所在缝隙的右侧，必须不能匹配 xxxxx 这部分表达式。如：&#8221;hello(?!\w)&rdquo; 在匹配字符串 &ldquo;hello,helloworld&#8221;时，匹配 hello&#8221;。这里使用 &rdquo;(?!\w)&ldquo; 和使用 &rdquo;\b&#8221; 效果一样。</p></li>
<li><p>反向预搜索：&#8221;(?&lt;=xxxxx)&ldquo;，&rdquo;(?&lt;!xxxxx)&#8221;</p>

<p>  和正向预搜索类似，反向预搜索要求的条件是：所在缝隙的 &ldquo;左侧&#8221;，两种格式分别要求必须能够匹配和必须不能够匹配指定表达式，而不是去判断右侧。与 &#8220;正向预搜索&rdquo; 一样的是：它们都是对所在缝隙的一种附加条件，本身都不匹配任何字符。</p></li>
</ul>


<h2>其他通用规则</h2>

<ul>
<li><p>可以使用 &ldquo;\xXX&rdquo; 和 &ldquo;\uXXXX&rdquo; 表示一个字符（&#8221;X&#8221; 表示一个十六进制数）</p>

<ul>
<li>\xXX: 编号在 0-255 范围的字符，如： 空格可以使用 &ldquo;\x20&rdquo; 表示</li>
<li>\uXXXX: 任何字符可以使用 &ldquo;\u&rdquo; 再加上其编号的4位十六进制数表示，比如： &ldquo;\u4E2D&rdquo;</li>
</ul>
</li>
<li><p>在表达式 &ldquo;\s&#8221;，&rdquo;\d&#8221;，&#8221;\w&#8221;，&#8221;\b&#8221; 表示特殊意义的同时，对应的大写字母表示相反的意义</p>

<ul>
<li>\S: 匹配所有非空白字符</li>
<li>\D: 匹配所有的非数字字符</li>
<li>\W: 匹配所有的字母、数字、下划线以外的字符</li>
<li>\B: 匹配非单词边界，即左右两边都是 &ldquo;\w&rdquo; 范围或者左右两边都不是 &ldquo;\w&rdquo; 范围时的字符缝隙</li>
</ul>
</li>
<li><p>括号&#8221;()&ldquo;内的子表达式，如果希望匹配结果不进行记录供以后使用，可以使用 &rdquo;(?:xxxxx)&ldquo;格式。如：表达式 &rdquo;(?:(\w)\1)+&ldquo; 匹配 &#8220;a bbccdd efg&rdquo; 时，结果是 &ldquo;bbccdd&#8221;。括号 &rdquo;(?:)&ldquo; 范围的匹配结果不进行记录，因此 &rdquo;(\w)&ldquo; 使用 &rdquo;\1&#8221; 来引用。</p></li>
<li><p>常用的表达式属性设置包括：Ignorecase、Singleline、Multiline、Global</p>

<ul>
<li>Ignorecase: 默认情况下，表达式中的字母是要区分大小写的。配置为 Ignorecase 可使匹配时不区分大小写。有的表达式引擎，把 &ldquo;大小写&rdquo; 概念延伸至 UNICODE 范围的大小写。</li>
<li>Singleline: 默认情况下，小数点 &ldquo;.&rdquo; 匹配除了换行符（\n）以外的字符。配置为Singleline可使小数点可匹配包括换行符在内的所有字符。</li>
<li><p>Multiline: 默认情况下，表达式 &ldquo;^&rdquo; 和 &ldquo;$&rdquo; 只匹配字符串的开始1和结尾4位置。如：</p>

<p>  1xxxxxxxxx2\n
  3xxxxxxxxx4</p>

<p>  配置为 Multiline 可以使 &ldquo;^&rdquo; 匹配1外，还可以匹配换行符之后，下一行开始前3的位置，&#8221;$&ldquo; 匹配4外，还可以匹配换行符之前，一行结束2的位置。使用(?m)可以设置为Multiline模式。如&rdquo;(?m)^\n +&ldquo;。</p></li>
<li>Global: 主要在将表达式用来替换时起作用，配置为Global表示替换所有的匹配。</li>
</ul>
</li>
</ul>


<h2>提示</h2>

<ul>
<li>如果要求表达式所匹配的内容是整个字符串，而不是其中的一部分，可以在表达式的首尾使用 &ldquo;^&rdquo; 和 &ldquo;$&#8221;，比如：&rdquo;^\d+$&ldquo; 要求整个字符串只有数字。</li>
<li>如果要求匹配的内容是一个完整的单词，而不会是单词的一部分，那么在表达式首尾使用 &ldquo;\b&#8221;，如： 使用 &rdquo;\b(if|while|&hellip;)\b&#8221; 来匹配程序中的关键字。</li>
<li>表达式不要匹配空字符串。否则会一直得到匹配成功，而结果什么都没有匹配到。</li>
<li>能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配0次，而这个括号整体又可以匹配无限次，那么匹配过程中可能死循环。</li>
<li>&ldquo;|&rdquo; 的左右两边，对某个字符应该只有一边可以匹配，以防止&#8221;|&ldquo;两边的表达式因为交换位置而有所不同。</li>
<li>要合理选择贪婪模式与非贪婪模式，如.* 与 .*?的区别使用。</li>
</ul>


<hr />

<p>中华万年历技术团队长期求Java研发工程师，给你挑战<strong>亿级用户</strong>、<strong>千万日活APP</strong>开发的机会。感兴趣者可发送简历到<a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x68;&#97;&#110;&#103;&#x40;&#101;&#x74;&#x6f;&#117;&#x63;&#x68;&#46;&#x63;&#x6e;">&#x68;&#97;&#110;&#103;&#64;&#x65;&#116;&#111;&#117;&#99;&#x68;&#x2e;&#99;&#x6e;</a>。要求如下：</p>

<p><img src="http://www.rowkey.me/images/blog_images/java_job.jpg" width="350" style="margin:0 auto;display:block"/></p>

<p>详见:<a href="https://m.zhipin.com/weijd/v2/job/0cdf0b4c4c3029521nN5392-FFc~">https://m.zhipin.com/weijd/v2/job/0cdf0b4c4c3029521nN5392-FFc~</a></p>
]]></content>
  </entry>
  
</feed>
