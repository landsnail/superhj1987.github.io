---
layout: post
title: "这些知识决定了程序员的上限"
date: 2019-04-22 19:29:34 +0800
comments: true
categories: misc
---

讲述决定程序员上限的一些知识技能点，包括如何学习、如何阅读源码、计算机科学基础知识体系等。

<!--more-->

## 什么是程序员？

- 码农、程序猿、程序媛
- 使用**程序**实现价值
- 程序=数据+算法
- 软件=程序+软件工程
- 程序员=工程师？

## 程序员金字塔

<img src="/post_images/ufp/programmer-pyramid.png" width="500"/>

## 程序员知识结构

![](/post_images/ufp/knowledge.png)

- 面试造火箭，工作打蚊子
- 会什么是你的下限，能够会什么是你的上限
- 越底层的东西越决定上限

## 学习欲望

> 杜绝**1**年工作经验重复**N**年

- 如果自己遇到这种问题会怎么解决，与资料中的解决方案相比优劣如何？
- 别人为什么会想到这种解决方案？
- 自己是由于经验欠缺还是技能点欠缺才导致没有想到好的解决方案？
- 解决这类问题的根本思路是什么样的？

## 学习能力

> 不是懂得多，而是学得快

- **知其然更要知其所以然**：技术以深度优先
- **类比现实**：对现实世界的模拟
- **更好地接受信息**：建立自己的知识体系；阅读并记笔记，纳入知识体系
- **深度思考**：阅读书籍
- **动手实践、频繁练习**：项目驱动型学习；主动思考
- **自我总结**：完善知识体系；笔记、博客、分享
- **持续学习**：逃离舒适区；学到老，活到老

## 如何学习新技术

<img src="/post_images/ufp/study-new-tech.png" width="500"/>

## 如何阅读源码

1. 阅读该技术的架构文档，了解其总体架构和组成
2. 根据总体架构，将源码文件以模块或者上下层级进行分类。
3. 从未阅读过的模块中选择最独立（依赖性最小）的模块代码读起。
4. 阅读此模块的功能介绍文档。
5. 阅读此模块的源代码：**运行程序，断点调试**。
6. 一边阅读一边整理调用关系图。
7. 转到第三步。

> 参考**官方文档或者经典书籍**

## 计算机思维

- **冯.诺依曼体系**：程序存储，顺序执行。
- **二进制存储**：用比特解决问题
- **位运算**：位运算的高效
- **逻辑分支**：条件判断、循环、迭代、递归

## 个人规划

- **长期规划**：职业规划；高瞻远瞩
- **短期规划**：具体技能、晋升、学习方面的规划；优先级排序

## 基础学科

- **物理**：电路原理；量子计算机
- **数学**：工程优化；线性代数；微积分
- **英语！！**：阅读英文文献；计算机术语

## 计算机组成原理

> 计算机的硬件组成和运行原理

- **冯诺依曼体系**、**摩尔定律**、**阿曼达定律**
- **数据的机器表示**：原码、补码、反码、浮点数/定点数
- **指令系统**：复杂指令集、简单指令集
- **存储器**：分类、缓存
- **CPU**: 流水线、伪共享、缓存
- **IO设备**：IO总线、DMA、中断

## 计算机操作系统

> 屏蔽计算机硬件的中间层

- **作业调度**: 调度策略、优先级
- **进程管理**：进程和线程、进程间通信
- **存储管理**：内存、虚拟内存、文件系统、页、页缓存
- **IO管理**：IO设备读写操作
- Linux操作系统

## 计算机网络

> 单个计算机之间的互连

- **TCP/IP协议栈**：四层/七层
- TCP连接状态
- TCP与UDP的区别
- HTTP协议、RESTful规范
- 网络安全
- **下一代互联网**：IPv6、物联网、5G

## 编译原理

> 将代码转换成机器可理解的二进制，有助于实现DSL

- 词法分析、语法分析
- 类型检查
- 运行时环境、中间代码
- 代码生成、代码优化

## 数据结构和算法

> 程序=数据+算法

- **基本数据结构**：数组、链表、栈、队列、哈希表
- **最大堆、最小堆**：TopN问题
- **树**：平衡二叉树、B树、B+树、红黑树
- **跳跃表**: 简单可实现
- **经典排序算法**：快速排序、归并排序、插入排序、冒泡排序
- **经典查找算法**：顺序查找、二分查找
- **高级算法**：贪心、分治、回溯、动态规划
- **大数据处理**：Bitmap、Bloomfilter、Hyperloglog、MapReduce、MPP

## 设计模式

> 软件可复用、可扩展、可维护。善用而不滥用。

- **面向对象SOLID设计原则**：单一职责、开闭原则、里氏代换、接口隔离、依赖倒转
- **常用设计模式**：单例模式、工厂模式、代理模式、适配器模式、观察者模式
- **常用框架中的设计模式**：Spring