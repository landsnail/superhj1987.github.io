
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!-->
<html class="no-js" lang="zh-CN"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>后端技术杂谈 | 飒然Hang</title>
  <meta name="author" content="飒然Hang">
  <!--[if lt IE 9]>
    <script src="http://x.papaapp.com/farm1/a571d2/8dda131d/html5shiv.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
    <![endif]-->
  
  <meta name="description" content="使用Spring Boot快速开发 Jul 27th, 2019 本章开始提到Spring现在变得越来越复杂，越来越不好上手。这一点Spring Source自己也注意到了，因此推出了Spring Boot，旨在简化使用Spring的门槛，大大降低Spring的配置工作， &hellip;">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.rowkey.me/">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <!-- <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script> -->
  <script src="//cdn.staticfile.org/jquery/2.0.3/jquery.min.js"></script>
  <link href="/atom.xml" rel="alternate" title="后端技术杂谈 | 飒然Hang" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link rel="stylesheet" href="/stylesheets/comment.css">
<link rel="stylesheet" href="//cdn.staticfile.org/highlight.js/9.10.0/styles/default.min.css">
<style type="text/css">
  span#cnzz_stat_icon_1257166229{
  	display: none !important
  }
  .btn_primary{
    color: #fff;
    background-color: #006dcc;
    background-image: linear-gradient(to bottom,#08c,#04c);
    border-color: rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);
    padding: 4px 12px;
    margin-bottom: 0;
    font-size: 14px;
    line-height: 20px;
    vertical-align: middle;
    cursor: pointer;
    border-radius: 4px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.2), 0 1px 2px rgba(0,0,0,.05);
    display: inline-block;
    text-align: center;
  }
  #recent-comments .comment-widget-content {
      color: #000000 !important;
  }
</style>

  

</head>
<body   >
  <header id="header" class="clearfix">    <!-- cnzz统计 -->
    <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1257166229'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1257166229%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                <a id="logo" href="/">
                   后端技术杂谈
                </a>
                <p class="description">What、How、Why</p>
            </div>
            <div id="m-search">
                <section class="widget">
    <form action="http://cn.bing.com/search" method="get" target="_blank" onsubmit="return doSearch(this)">
    <div class="content">
      <input type="text" class="textfield searchtip" name="s" placeholder="请输入关键字" size="24" value="">
    </div>
    </form>
    <form action="http://cn.bing.com/search" method="get" target="_blank" style="display:none" name="frmSearch">
    <div class="content">
      <input type="hidden" name="q" value="">
    </div>
    </form>
</section>
<script type="text/javascript">
  function doSearch(o){
    var $s = $(o).find("input[name=s]");
    var $q = $(o).next("form").find("input[name=q]");
    $q.val($s.val() + " site:rowkey.me");
    $(o).next("form").submit();
    return false;
  }
</script>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="index-nav current" href="/">首页</a>
<a class="java-nav" href="/blog/categories/java">Java</a>
<a class="architecture-nav" href="/blog/categories/architecture">架构</a>
<a class="categories-nav" href="/blog/categories">分类</a>
<a class="archives-nav" href="/blog/archives">归档</a>
<a class="about-nav" href="/about_me.html">关于</a>
                </nav>
            </div>
        </div>
    </div>
</header>
  <div id="body">
    <div class="container">
    	<div class="col-group">
			  <div class="col-8" id="main">
    <div class="res-cons">
    
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2019/07/27/springboot/">使用Spring Boot快速开发</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2019-07-27T11:29:34+00:00" pubdate data-updated="true">Jul 27<sup>th</sup>, 2019</time>
        
        
      </p>
    
  </header>


  <div class="post-content"><p>本章开始提到Spring现在变得越来越复杂，越来越不好上手。这一点Spring Source自己也注意到了，因此推出了Spring Boot，旨在简化使用Spring的门槛，大大降低Spring的配置工作，并且能够很容易地将应用打包为可独立运行的程序（即不依赖于第三方容器，可以独立以jar或者war包的形式运行）。其带来的开发效率的提升使得Spring Boot被看做至少近5年来Spring乃至整个Java社区最有影响力的项目之一，也被人看作是Java EE开发的颠覆者。另一方面来说，Spring Boot也顺应了现在微服务（MicroServices）的理念，可以用来构建基于Spring框架的可独立部署应用程序。</p>

<h2>一. 使用</h2>

<p>一个简单的pom配置示例如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;parent&gt;        
</span><span class='line'>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        
</span><span class='line'>   &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        
</span><span class='line'>   &lt;version&gt;1.4.7.RELEASE&lt;/version&gt;
</span><span class='line'>&lt;/parent&gt;
</span><span class='line'>    
</span><span class='line'>...
</span><span class='line'>    
</span><span class='line'>&lt;dependencies&gt;        
</span><span class='line'>   &lt;dependency&gt;                
</span><span class='line'>       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                
</span><span class='line'>       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        
</span><span class='line'>   &lt;/dependency&gt;
</span><span class='line'>&lt;/dependencies&gt;
</span><span class='line'>
</span><span class='line'>&lt;build&gt;
</span><span class='line'>    &lt;plugins&gt;
</span><span class='line'>       &lt;plugin&gt;
</span><span class='line'>           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
</span><span class='line'>           &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
</span><span class='line'>           &lt;configuration&gt;
</span><span class='line'>               &lt;executable&gt;true&lt;/executable&gt;
</span><span class='line'>            &lt;/configuration&gt;
</span><span class='line'>       &lt;/plugin&gt;
</span><span class='line'>    &lt;/plugins&gt;
</span><span class='line'>&lt;/build&gt;</span></code></pre></td></tr></table></div></figure>


<p>使用spring-boot-starter-parent作为当前项目的parent将Spring Boot应用相关的一系列依赖（dependency）、插件（plugins）等等配置共享；添加spring-boot-starter-web这个依赖，是为了构建一个独立运行的Web应用；spring-boot-maven-plugin用于将Spring Boot应用以可执行jar包的形式发布出去。</p>

<p>接着可以添加相应的Controller实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RestController  
</span><span class='line'>public class MyController {
</span><span class='line'>@RequestMapping("/")
</span><span class='line'>   public String hello() {
</span><span class='line'>      return "Hello World!";
</span><span class='line'>   }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里的RestController是一个复合注解，包括@Controller和@ResponseBody。</p>

<p>最后，要让Spring Boot可以独立运行和部署，我们需要一个Main方法入口， 比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@SpringBootApplication
</span><span class='line'>public class BootDemo extends SpringBootServletInitializer{    
</span><span class='line'>   public static void main(String[] args) throws Exception {        
</span><span class='line'>       SpringApplication.run(BootDemo.class, args);    
</span><span class='line'>   }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>使用mvn package打包后（可以是jar，也可以是war），java -jar xx.war/jar即可运行一个Web项目，而之所以继承SpringBootServletInitializer是为了能够让打出来的war包也可以放入容器中直接运行，其加载原理在3.4.4节的零XML配置中讲过。</p>

<p>这里需要注意上面spring-boot-maven-plugin这个插件将executable配置为了true，此种配置打出来的jar/war包其压缩格式并非传统的jar/war包，实际上是一个bash文件，可以作为shell脚本直接执行，解压的话需要使用unzip命令。</p>

<p>从最根本上来讲，Spring Boot就是一些库和插件的集合，屏蔽掉了很多配置加载、打包等自动化工作，其底层还是基于Spring的各个组件。</p>

<p>这里需要注意的是，Spring Boot推崇对项目进行零xml配置。但是就笔者看来，相比起注解配置是糅杂在代码中，每次更新都需要重新编译，XML这种和代码分离的方式耦合性和可维护性则显得更为合理一些，而且在配置复杂时也更清晰。因此，采用Java Config作为应用和组件扫描（component scan）入口，采用XML做其他的配置是一种比较好的方式。此外，当集成外部已有系统的时候， 通过XML集中明确化配置也是更为合理的一种方式。</p>

<h2>二. 原理浅析</h2>

<p><img src="/post_images/spring-boot-process.png" alt="" /></p>

<p>Spring Boot的基础组件之一就是4.1讲过的一些注解配置，除此之外，它也提供了自己的注释。其总体的运行流程如上图所示。</p>

<ol>
<li><p>@EnableAutoConfiguration</p>

<p> 这个Annotation就是Java Config的典型代表，标注了这个Annotation的Java类会以Java代码的形式（对应于XML定义的形式）提供一系列的Bean定义和实例，结合AnnotationConfigApplicationContext和自动扫描的功能，就可以构建一个基于Spring容器的Java应用了。</p>

<p> @EnableAutoConfiguration的定义信息如下 ：</p>

<pre><code class="`"> @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
 @Inherited
 @AutoConfigurationPackage
 @Import(EnableAutoConfigurationImportSelector.class)
 public @interface EnableAutoConfiguration {
</code></pre>

<p> 标注了此注解的类会发生一系列初始化动作：</p>

<ul>
<li><p>SpringBoot扫描到@EnableAutoConfiguration注解时，就使用Spring框架的SpringFactoriesLoader去扫描classpath下所有META-INF/spring.factories文件的配置信息（META-INF/spring.providers声明了当前Starter依赖的Jar包）。其中包括一些callback接口（在前中后等不同时机执行）：</p>

<ul>
<li>org.springframework.boot.SpringApplicationRunListener</li>
<li>org.springframework.context.ApplicationContextInitializer</li>
<li>org.springframework.context.ApplicationListener</li>
</ul>
</li>
<li><p>然后Spring Boot加载符合当前场景需要的配置类型并供当前或者下一步的流程使用，这里说的场景就是提取以 org.springframework.boot.autoconfigure.EnableAutoConfiguration作为key标志的一系列Java配置类，然后将这些Java配置类中的Bean定义加载到Spring容器中。</p></li>
</ul>


<p> 此外，我们可以使用Spring3系列引入的@Conditional，通过像@ConditionalOnClass、@ConditionalOnMissingBean等具体的类型和条件来进一步筛选通过SpringFactoriesLoader加载的类。</p></li>
<li><p>Spring Boot启动</p>

<p> 每一个Spring Boot应用都有一个入口类，在其中定义main方法，然后使用SpringApplication这个类来加载指定配置并运行SpringBoot Application。如上面写过的入口类：</p>

<pre><code class="`   "> @SpringBootApplication
 public class BootDemo extends SpringBootServletInitializer{    
    public static void main(String[] args) throws Exception {        
        SpringApplication.run(BootDemo.class, args);    
    }
 }
</code></pre>

<p> @SpringBootApplication注解是一个复合注解，包括了@Configuraiton、@EnableAutoConfiguration以及@ComponentScan。通过SpringApplication的run方法，Spring就使用BootDemo作为Java配置类来读取相关配置、加载和扫描相关的bean。</p>

<p> 这样，基于@SpringBootApplication注解，Spring容器会自动完成指定语义的一系列工作，包括@EnableAutoConfiguration要求的东西，如：从SpringBoot提供的多个starter模块中加载Java Config配置（META-INF/spring.factories中声明的xxAutoConfiguration），然后将这些Java Config配置筛选上来的Bean定义加入Spring容器中，再refresh容器。一个Spring Boot应用即启动完成。</p></li>
</ol>


<h2>三. 模块组成</h2>

<p>Spring Boot是由非常多的模块组成的，可以通过pom文件引入进来。EnableAutoConfiguration机制会进行插件化加载进行自动配置，这里模块化机制的原理主要是通过判断相应的类/文件是否存在来实现的。其中几个主要的模块如下:</p>

<ol>
<li><p>spring-boot-starter-web</p>

<p> 此模块就是标记此项目是一个Web应用，Spring Boot会自动准备好相关的依赖和配置。</p>

<p> 这里Spring Boot默认使用Tomcat作为嵌入式Web容器，可以通过声明spring-boot-starter-jetty的dependency来换成Jetty。</p></li>
<li><p>spring-boot-starter-logging</p>

<p> Spring Boot对此项目开启SLF4J和Logback日志支持。</p></li>
<li><p>spring-boot-starter-redis</p>

<p>  Spring Boot对此项目开启Redis相关依赖和配置来做数据存储。</p></li>
<li><p>spring-boot-starter-jdbc</p>

<p>  Spring Boot对此项目开启JDBC操作相关依赖和配置来做数据存储。</p>

<p>  这里需要说明的是，Spring Boot提供的功能非常丰富，因此显得非常笨重复杂。其实依赖于模块插件化机制，我们可以只配置自己需要使用的功能，从而对应用进行瘦身，避免无用的配置影响应用启动速度。</p></li>
</ol>


<h2>四. 总结</h2>

<p>Spring Boot给大家使用Spring做后端应用开发带来了非常大的便利，能够大大提高搭建应用雏形框架的速度，只需要关注实现业务逻辑即可。其“黑魔法”一样的插件化机制使得能够根据自己的需要引入所需的组件，提供了非常好的灵活性。如果非遗留Spring项目，直接使用Spring Boot是比较好的选择；遗留项目也可以通过配置达到无缝结合。</p>

<blockquote><p>本文节选自《Java工程师修炼之道》一书。</p></blockquote>
</div>
  
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2019/06/29/log/">Java开发框架之日志</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2019-06-29T11:29:34+00:00" pubdate data-updated="true">Jun 29<sup>th</sup>, 2019</time>
        
        
      </p>
    
  </header>


  <div class="post-content"><p>日志在应用开发中是一个非常关键的部分。有经验的工程师能够凭借以往的经验判断出哪里该打印日志、该以何种级别打印日志。这样就能够在线上发生问题的时候快速定位并解决问题，极大的减少应用的运维成本。</p>

<p>使用控制台输出其实也算日志的一种，在容器中会打印到容器的日志文件中。但是，控制台输出过于简单，缺乏日志中级别控制、异步、缓冲等特性，因此在开发中要杜绝使用控制台输出作为日志（System.out.println）。而Java中已经有很多成熟的日志框架供大家使用：</p>

<ul>
<li>JDK Logging</li>
<li>Apache Log4j</li>
<li>Apache Log4j2</li>
<li>Logback</li>
</ul>


<p>此外，还有两个用于实现日志统一的框架：Apache Commons-Logging、SLF4j。与上述框架的不同之处在于，其只是一个门面，并没有日志框架的具体实现,可以认为是日志接口框架。</p>

<p>对于这些日志框架来说，一般会解决日志中的以下问题：</p>

<ul>
<li>日志的级别: 定义日志级别来区分不同级别日志的输出路径、形式等，帮助我们适应从开发调试到部署上线等不同阶段对日志输出粒度的不同需求。</li>
<li>日志的输出目的地：包括控制台、文件、GUI组件，甚至是套接口服务器、UNIX Syslog守护进程等。</li>
<li>日志的输出格式：日志的输出格式（JSON、XML）。</li>
<li>日志的输出优化：缓存、异步等。</li>
</ul>


<p>这里需要说的是，目前有几个框架提供了占位符的日志输出方式，然而其最终是用indexOf去循环查找再对信息进行拼接的，会消耗CPU。建议使用正确估算大小的StringBuilder拼装输出信息，除非是实在无法确定日志是否输出才用占位符。</p>

<h2>一. JDK Logging</h2>

<p>JDK Logging就是JDK自带的日志操作类，在java.util.logging包下面，通常被简称为JUL。</p>

<h3>配置</h3>

<p>JDK Logging配置文件默认位于$JAVA_HOME/jre/lib/logging.properties中，可以使用系统属性java.util.logging.config.file指定相应的配置文件对默认的配置文件进行覆盖。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>handlers= java.util.logging.FileHandler,java.util.logging.ConsoleHandler
</span><span class='line'>.handlers = java.util.logging.FileHandler,java.util.logging.ConsoleHandler #rootLogger使用的Handler
</span><span class='line'>.level= INFO #rootLogger的日志级别
</span><span class='line'>
</span><span class='line'>##以下是FileHandler的配置
</span><span class='line'>java.util.logging.FileHandler.pattern = %h/java%u.log
</span><span class='line'>java.util.logging.FileHandler.limit = 50000
</span><span class='line'>java.util.logging.FileHandler.count = 1
</span><span class='line'>java.util.logging.FileHandler.formatter =java.util.logging.XMLFormatter #配置相应的日志Formatter。
</span><span class='line'>
</span><span class='line'>##以下是ConsoleHandler的配置
</span><span class='line'>java.util.logging.ConsoleHandler.level = INFO
</span><span class='line'>java.util.logging.ConsoleHandler.formatter =java.util.logging.SimpleFormatter #配置相应的日志Formatter。
</span><span class='line'>
</span><span class='line'>#针对具体的某个logger的日志级别配置
</span><span class='line'>me.rowkey.pje.log.level = SEVERE
</span><span class='line'>
</span><span class='line'>#设置此logger不会继承成上一级logger的配置
</span><span class='line'>me.rokey.pje.log.logger.useParentHandlers = false </span></code></pre></td></tr></table></div></figure>


<p>这里需要说明的是logger默认是继承的，如me.rowkey.pje.log的logger会继承me.rowkey.pje的logger配置，可以对logger配置handler和useParentHandlers（默认是为true）属性, 其中useParentHandler表示是否继承父logger的配置。</p>

<p>JDK Logging的日志级别比较多，从高到低为：OFF(2<sup>31</sup>-1)—>SEVERE(1000)—>WARNING(900)—>INFO(800)—>CONFIG(700)—>FINE(500)—>FINER(400)—>FINEST(300)—>ALL(-2<sup>31</sup>)。</p>

<h3>使用</h3>

<p>JDK Logging的使用非常简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class LoggerTest{
</span><span class='line'>
</span><span class='line'>    private static final Logger LOGGER = Logger.getLogger(xx.class.getName());
</span><span class='line'>    
</span><span class='line'>    public static void main(String[] args){
</span><span class='line'>        LOGGER.info("logger info");
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<h3>性能优化</h3>

<p>JDK Logging是一个比较简单的日志框架，并没有提供异步、缓冲等优化手段。也不建议大家使用此框架。</p>

<h2>二. Log4j</h2>

<p>Log4j应该是目前Java开发中用的最为广泛的日志框架。</p>

<h3>配置</h3>

<p>Log4j支持XML、Proerties配置，通常还是使用Properties：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root_log_dir=${catalina.base}/logs/app/
</span><span class='line'>
</span><span class='line'># 设置rootLogger的日志级别以及appender
</span><span class='line'>log4j.rootLogger=INFO,default
</span><span class='line'>
</span><span class='line'># 设置Spring Web的日志级别
</span><span class='line'>log4j.logger.org.springframework.web = ERROR
</span><span class='line'>
</span><span class='line'># 设置default appender为控制台输出
</span><span class='line'>log4j.appender.default=org.apache.log4j.ConsoleAppender
</span><span class='line'>log4j.appender.default.layout=org.apache.log4j.PatternLayout
</span><span class='line'>log4j.appender.default.layout.ConversionPattern=[%-d{HH\:mm\:ss} %-3r %-5p %l] &gt;&gt; %m (%t)%n
</span><span class='line'>
</span><span class='line'># 设置新的logger，在程序中使用Logger.get("myLogger")即可使用
</span><span class='line'>log4j.logger.myLogger=INFO,A2
</span><span class='line'>
</span><span class='line'># 设置另一个appender为按照日期轮转的文件输出
</span><span class='line'>log4j.appender.A2=org.apache.log4j.DailyRollingFileAppender
</span><span class='line'>log4j.appender.A2.File=${root_log_dir}log.txt
</span><span class='line'>log4j.appender.A2.Append=true
</span><span class='line'>log4j.appender.A2.DatePattern= yyyyMMdd'.txt'
</span><span class='line'>log4j.appender.A2.layout=org.apache.log4j.PatternLayout
</span><span class='line'>log4j.appender.A2.layout.ConversionPattern=[%-d{HH\:mm\:ss} %-3r %-5p %l] &gt;&gt; %m (%t)%n
</span><span class='line'>
</span><span class='line'>log4j.logger.myLogger1 = INFO,A3
</span><span class='line'>
</span><span class='line'># 设置另一个appender为RollingFileAppender，能够限制日志文件个数
</span><span class='line'>log4j.appender.A3 = org.apache.log4j.RollingFileAppender
</span><span class='line'>log4j.appender.A3.Append = true
</span><span class='line'>log4j.appender.A3.BufferedIO = false
</span><span class='line'>log4j.appender.dA3.File = /home/popo/tomcat-yixin-pa/logs/pa.log
</span><span class='line'>log4j.appender.A3.Encoding = UTF-8
</span><span class='line'>log4j.appender.A3.layout = org.apache.log4j.PatternLayout
</span><span class='line'>log4j.appender.A3.layout.ConversionPattern = [%-5p]%d{ISO8601}, [Class]%-c{1}, %m%n
</span><span class='line'>log4j.appender.A3.MaxBackupIndex = 3 #最大文件个数
</span><span class='line'>log4j.appender.A3.MaxFileSize = 1024MB</span></code></pre></td></tr></table></div></figure>


<p>如果Log4j文件不直接在classpath下的话，可以使用PropertyConfigurator来进行配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PropertyConfigurator.configure("...");
</span></code></pre></td></tr></table></div></figure>


<p>Log4j的日志级别相对于JDK Logging来说，简化了一些：DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL。</p>

<p>这里的logger默认是会继承父Logger的配置（rootLogger是所有logger的父logger），如上面myLogger的输出会同时在控制台和文件中出现。如果不想这样，那么只需要如下设置:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>log4j.additivity.myLogger=false</span></code></pre></td></tr></table></div></figure>


<h3>使用</h3>

<p>程序中对于Log4j的使用也非常简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import org.apache.log4j.Logger;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>private static final Logger LOGGER = Logger.getLogger(xx.class.getName());
</span><span class='line'>...
</span><span class='line'>LOGGER.info("logger info");
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>这里需要注意的是，虽然Log4j可以根据配置文件中日志级别的不同做不同的输出，但由于字符串创建或者拼接也是耗资源的，因此，下面的用法是不合理的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LOGGER.debug("...");</span></code></pre></td></tr></table></div></figure>


<p>合理的做法应该是首先判断当前的日志级别是什么，再去做相应的输出，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(LOGGER.isDebugEnabled()){
</span><span class='line'>    LOGGER.debug("...");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当然，如果是必须输出的日志可以不做此判断，比如catch异常打印错误日志的地方。</p>

<h3>性能优化</h3>

<p>Log4j为了应对某一时间里大量的日志信息进入Appender的问题提供了缓冲来进一步优化性能：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>log4j.appender.A3.BufferedIO=true   
</span><span class='line'>#Buffer单位为字节，默认是8K，IO BLOCK大小默认也是8K 
</span><span class='line'>log4j.appender.A3.BufferSize=8192 </span></code></pre></td></tr></table></div></figure>


<p>以上表示当日志内容达到8k时，才会将日志输出到日志输出目的地。</p>

<p>除了缓冲以外，Log4j还提供了AsyncAppender来做异步日志。但是AsyncAppender只能够通过xml配置使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;appender name="A2"
</span><span class='line'>   class="org.apache.log4j.DailyRollingFileAppender"&gt;
</span><span class='line'>   &lt;layout class="org.apache.log4j.PatternLayout"&gt;
</span><span class='line'>       &lt;param name="ConversionPattern" value="%m%n" /&gt;
</span><span class='line'>   &lt;/layout&gt;
</span><span class='line'>   &lt;param name="DatePattern" value="'.'yyyy-MM-dd-HH" /&gt;        
</span><span class='line'>   &lt;param name="File" value="app.log" /&gt;
</span><span class='line'>   &lt;param name="BufferedIO" value="true" /&gt;
</span><span class='line'>   &lt;!-- 8K为一个写单元 --&gt;
</span><span class='line'>   &lt;param name="BufferSize" value="8192" /&gt;
</span><span class='line'>&lt;/appender&gt;
</span><span class='line'>
</span><span class='line'>&lt;appender name="async" class="org.apache.log4j.AsyncAppender"&gt;
</span><span class='line'>   &lt;appender-ref ref="A2"/&gt;
</span><span class='line'>&lt;/appender&gt;</span></code></pre></td></tr></table></div></figure>


<h2>三. Log4j2</h2>

<p>2015年8月，官方正式宣布Log4j 1.x系列生命终结，推荐大家升级到Log4j2，并号称在修正了Logback固有的架构问题的同时，改进了许多Logback所具有的功能。Log4j2与Log4j1发生了很大的变化，并不兼容。并且Log4j2不仅仅提供了日志的实现，也提供了门面，目的是统一日志框架。其主要包含两部分：</p>

<ul>
<li>log4j-api： 作为日志接口层，用于统一底层日志系统</li>
<li>log4j-core : 作为上述日志接口的实现，是一个实际的日志框架</li>
</ul>


<h3>配置</h3>

<p>Log4j2的配置方式只支持XML、JSON以及YAML，不再支持Properties文件,其配置文件的加载顺序如下：</p>

<ul>
<li>log4j2-test.json/log4j2-test.jsn</li>
<li>log4j2-test.xml</li>
<li>log4j2.json/log4j2.jsn文件</li>
<li>log4j2.xml</li>
</ul>


<p>如果想要自定义配置文件位置，需要设置系统属性log4j.configurationFile。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>System.setProperty("log4j.configurationFile", "...");
</span><span class='line'>或者
</span><span class='line'>-Dlog4j.configurationFile="xx"</span></code></pre></td></tr></table></div></figure>


<p>配置文件示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!--log4j2.xml--&gt;
</span><span class='line'>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
</span><span class='line'>&lt;Configuration status="WARN" monitorInterval="30"&gt;
</span><span class='line'>&lt;Appenders&gt;
</span><span class='line'>  &lt;Console name="Console" target="SYSTEM_OUT"&gt;
</span><span class='line'>    &lt;PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/&gt;
</span><span class='line'>  &lt;/Console&gt;
</span><span class='line'>  &lt;File name="File" fileName="app.log" bufferedIO="true" immediateFlush="true"&gt;
</span><span class='line'>    &lt;PatternLayout&gt;
</span><span class='line'>      &lt;pattern&gt;%d %p %C{1.} [%t] %m%n&lt;/pattern&gt;
</span><span class='line'>    &lt;/PatternLayout&gt;
</span><span class='line'>  &lt;/File&gt;
</span><span class='line'>  &lt;RollingFile name="RollingFile" fileName="logs/app.log"
</span><span class='line'>                     filePattern="log/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz"&gt;
</span><span class='line'>      &lt;PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss z} %-5level %class{36} %L %M - %msg%xEx%n"/&gt;
</span><span class='line'>      &lt;SizeBasedTriggeringPolicy size="50MB"/&gt;
</span><span class='line'>      &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;
</span><span class='line'>      &lt;DefaultRolloverStrategy max="20"/&gt;
</span><span class='line'>  &lt;/RollingFile&gt;
</span><span class='line'>&lt;/Appenders&gt;
</span><span class='line'>&lt;Loggers&gt;
</span><span class='line'>  &lt;logger name="myLogger" level="error" additivity="false"&gt;
</span><span class='line'>    &lt;AppenderRef ref="File" /&gt;
</span><span class='line'>  &lt;/logger&gt;
</span><span class='line'>  &lt;Root level="debug"&gt;
</span><span class='line'>    &lt;AppenderRef ref="Console"/&gt;
</span><span class='line'>  &lt;/Root&gt;
</span><span class='line'>&lt;/Loggers&gt;
</span><span class='line'>&lt;/Configuration&gt;</span></code></pre></td></tr></table></div></figure>


<p>上面的monitorInterval使得配置变动能够被实时监测并更新，且能够在配置发生改变时不会丢失任何日志事件;additivity和Log4j一样也是为了让Looger不继承父Logger的配置；Configuration中的status用于设置Log4j2自身内部的信息输出，当设置成trace时，你会看到Log4j2内部各种详细输出。</p>

<p>Log4j2在日志级别方面也有了一些改动：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL, 并且能够很简单的自定义自己的日志级别。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;CustomLevels&gt;
</span><span class='line'>    &lt;CustomLevel name="NOTICE" intLevel="450" /&gt;
</span><span class='line'>    &lt;CustomLevel name="VERBOSE" intLevel="550" /&gt;
</span><span class='line'>&lt;/CustomLevels&gt;</span></code></pre></td></tr></table></div></figure>


<p>上面的intLevel值是为了与默认提供的标准级别进行对照的。</p>

<h3>使用</h3>

<p>使用方式也很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private static final Logger LOGGER = LogManager.getLogger(xx.class);
</span><span class='line'>
</span><span class='line'>LOGGER.debug("log4j debug message");</span></code></pre></td></tr></table></div></figure>


<p>这里需要注意的是其中的Logger是log4j-api中定义的接口，而Log4j1中的Logger则是类。</p>

<p>相比起之前我们需要先判断日志级别，再输出日志，Log4j2提供了占位符功能：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LOGGER.debug("error: {} ", e.getMessage());</span></code></pre></td></tr></table></div></figure>


<h3>性能优化</h3>

<p>在性能方面，Log4j2引入了基于LMAX的Disruptor的无锁异步日志实现进一步提升异步日志的性能：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;AsyncLogger name="asyncTestLogger" level="trace" includeLocation="true"&gt;
</span><span class='line'>    &lt;AppenderRef ref="Console"/&gt;
</span><span class='line'>&lt;/AsyncLogger&gt;</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，由于默认日志位置信息并没有被传给异步Logger的I/O线程，因此这里的includeLocation必须要设置为true。</p>

<p>和Log4j一样，Log4j2也提供了缓冲配置来优化日志输出性能。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Appenders&gt;
</span><span class='line'>  &lt;File name="File" fileName="app.log" bufferedIO="true" immediateFlush="true"&gt;
</span><span class='line'>    &lt;PatternLayout&gt;
</span><span class='line'>      &lt;pattern&gt;%d %p %C{1.} [%t] %m%n&lt;/pattern&gt;
</span><span class='line'>    &lt;/PatternLayout&gt;
</span><span class='line'>  &lt;/File&gt;
</span><span class='line'>&lt;/Appenders&gt;</span></code></pre></td></tr></table></div></figure>


<h2>四. Logback</h2>

<p>Logback是由Log4j创始人设计的又一个开源日志组件，相对Log4j而言，在各个方面都有了很大改进。</p>

<p>Logback当前分成三个模块：</p>

<ul>
<li>logback-core是其它两个模块的基础模块。</li>
<li>logback-classic是Log4j的一个改良版本。logback-classic完整实现SLF4J API使你可以很方便地更换成其它日志系统如Log4j或JDK Logging。</li>
<li>logback-access访问模块与Servlet容器集成提供通过HTTP来访问日志的功能。</li>
</ul>


<h3>配置</h3>

<p>Logback的配置文件如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!--logback.xml--&gt;
</span><span class='line'>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
</span><span class='line'>&lt;configuration&gt;
</span><span class='line'>
</span><span class='line'>    &lt;property name="root_log_dir" value="${catalina.base}/logs/app/"/&gt;
</span><span class='line'>
</span><span class='line'>    &lt;appender name="ROLLING_FILE_APPENDER" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
</span><span class='line'>       &lt;File&gt;${root_log_dir}app.log&lt;/File&gt;
</span><span class='line'>       &lt;Append&gt;true&lt;/Append&gt;
</span><span class='line'>       &lt;encoder&gt;
</span><span class='line'>           &lt;pattern&gt;%date [%level] [%thread] %logger{80} [%file : %line] %msg%n&lt;/pattern&gt;
</span><span class='line'>       &lt;/encoder&gt;
</span><span class='line'>       &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
</span><span class='line'>           &lt;fileNamePattern&gt;${root_log_dir}app.log.%d{yyyy-MM-dd}.%i&lt;/fileNamePattern&gt;
</span><span class='line'>           &lt;maxHistory&gt;30&lt;/maxHistory&gt; #只保留最近30天的日志文件
</span><span class='line'>           &lt;TimeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt;#每天的日志按照100MB分割
</span><span class='line'>                &lt;MaxFileSize&gt;100MB&lt;/MaxFileSize&gt;
</span><span class='line'>            &lt;/TimeBasedFileNamingAndTriggeringPolicy&gt;
</span><span class='line'>            &lt;totalSizeCap&gt;20GB&lt;/totalSizeCap&gt;#日志总的大小上限，超过此值则异步删除旧的日志
</span><span class='line'>       &lt;/rollingPolicy&gt;
</span><span class='line'>    &lt;/appender&gt;
</span><span class='line'>    
</span><span class='line'>    &lt;appender name="ROLLING_FILE_APPENDER_2" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
</span><span class='line'>       &lt;File&gt;${root_log_dir}mylog.log&lt;/File&gt;
</span><span class='line'>       &lt;Append&gt;true&lt;/Append&gt;
</span><span class='line'>       &lt;encoder&gt;
</span><span class='line'>           &lt;pattern&gt;%date [%level] [%thread] %logger{80} [%file : %line] %msg%n&lt;/pattern&gt;
</span><span class='line'>       &lt;/encoder&gt;
</span><span class='line'>       #下面的日志rolling策略和ROLLING_FILE_APPENDER的等价，保留最近30天的日志，每天的日志按照100MB分隔，日志总的大小上限为20GB
</span><span class='line'>       &lt;rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"&gt;
</span><span class='line'>            &lt;fileNamePattern&gt;mylog.log-%d{yyyy-MM-dd}.%i&lt;/fileNamePattern&gt;
</span><span class='line'>            &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;
</span><span class='line'>            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
</span><span class='line'>            &lt;totalSizeCap&gt;20GB&lt;/totalSizeCap&gt;
</span><span class='line'>        &lt;/rollingPolicy&gt;
</span><span class='line'>    &lt;/appender&gt;
</span><span class='line'>    
</span><span class='line'>     &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
</span><span class='line'>       &lt;encoder&gt;
</span><span class='line'>         &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
</span><span class='line'>       &lt;/encoder&gt;
</span><span class='line'>     &lt;/appender&gt;
</span><span class='line'>        
</span><span class='line'>    &lt;logger name="myLogger" level="INFO" additivity="false"&gt;
</span><span class='line'>        &lt;appender-ref ref="ROLLING_FILE_APPENDER" /&gt;
</span><span class='line'>    &lt;/logger&gt;
</span><span class='line'>        
</span><span class='line'>     &lt;root level="DEBUG"&gt;          
</span><span class='line'>       &lt;appender-ref ref="STDOUT" /&gt;
</span><span class='line'>     &lt;/root&gt;  
</span><span class='line'>
</span><span class='line'>&lt;/configuration&gt;</span></code></pre></td></tr></table></div></figure>


<p>Logback的配置文件读取顺序（默认都是读取classpath下的）：logback.groovy -> logback-test.xml -> logback.xml。如果想要自定义配置文件路径，那么只有通过修改logback.configurationFile的系统属性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>System.setProperty("logback.configurationFile", "...");
</span><span class='line'>或者
</span><span class='line'>-Dlogback.configurationFile="xx"</span></code></pre></td></tr></table></div></figure>


<p>Logback的日志级别：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR。如果logger没有被分配级别，那么它将从有被分配级别的最近的祖先那里继承级别。root logger 默认级别是 DEBUG。</p>

<p>Logback中的logger同样也是有继承机制的。配置文件中的additivit也是为了不去继承rootLogger的配置，从而避免输出多份日志。</p>

<p>为了方便Log4j到Logback的迁移，官网提供了log4j.properties到logback.xml的转换工具：<a href="https://logback.qos.ch/translator/">https://logback.qos.ch/translator/</a>。</p>

<h3>使用</h3>

<p>Logback由于是天然与SLF4J集成的，因此它的使用也就是SLF4J的使用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import org.slf4j.LoggerFactory;
</span><span class='line'>
</span><span class='line'>private static final Logger LOGGER=LoggerFactory.getLogger(xx.class);
</span><span class='line'>
</span><span class='line'>LOGGER.info(" this is a test in {}", xx.class.getName())</span></code></pre></td></tr></table></div></figure>


<p>SLF4J同样支持占位符。</p>

<p>此外，如果想要打印json格式的日志（例如，对接日志到Logstash中），那么可以使用logstash-logback-encoder做为RollingFileAppender的encoder。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;encoder class="net.logstash.logback.encoder.LogstashEncoder" &gt;
</span><span class='line'>...
</span><span class='line'>&lt;/encoder&gt;</span></code></pre></td></tr></table></div></figure>


<h3>性能优化</h3>

<p>Logback提供了AsyncAppender进行异步日志输出，此异步appender实现上利用了队列做缓冲，使得日志输出性能得到提高。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;appender name="FILE_APPENDER" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
</span><span class='line'>      &lt;File&gt;${root_log_dir}app.log&lt;/File&gt;
</span><span class='line'>      &lt;Append&gt;true&lt;/Append&gt;
</span><span class='line'>      &lt;encoder&gt;
</span><span class='line'>          &lt;pattern&gt;%date [%level] [%thread] %logger{80} [%file : %line] %msg%n&lt;/pattern&gt;
</span><span class='line'>      &lt;/encoder&gt;
</span><span class='line'>      &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
</span><span class='line'>          &lt;fileNamePattern&gt;${root_log_dir}app.log.%d&lt;/fileNamePattern&gt;
</span><span class='line'>      &lt;/rollingPolicy&gt;
</span><span class='line'>&lt;/appender&gt;
</span><span class='line'>&lt;appender name ="ASYNC" class= "ch.qos.logback.classic.AsyncAppender"&gt;  
</span><span class='line'>       &lt;discardingThreshold &gt;0&lt;/discardingThreshold&gt;  
</span><span class='line'>       
</span><span class='line'>       &lt;queueSize&gt;512&lt;/queueSize&gt;  
</span><span class='line'>       
</span><span class='line'>       &lt;appender-ref ref ="FILE_APPENDER"/&gt;  
</span><span class='line'>&lt;/appender&gt;  
</span><span class='line'>       </span></code></pre></td></tr></table></div></figure>


<p>这里需要特别注意以下两个参数的配置：</p>

<ul>
<li>queueSize：队列的长度,该值会影响性能，需要合理配置。</li>
<li>discardingThreshold：日志丢弃的阈值，即达到队列长度的多少会丢弃TRACT、DEBUG、INFO级别的日志，默认是80%，设置为0表示不丢弃日志。</li>
</ul>


<p>此外，由于是异步输出，为了保证日志一定会被输出以及后台线程能够被及时关闭，在应用退出时需要显示关闭logback。有两种方式：</p>

<ul>
<li><p>在程序退出的地方（ServletContextListener的contextDestroyed方法、Spring Bean的destroy方法）显式调用下面的代码。</p>

<pre><code class="``">  LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
  loggerContext.stop();
</code></pre></li>
<li><p>在logback配置文件里，做如下配置。</p>

<pre><code class="``">  &lt;configuration&gt;

      &lt;shutdownHook class="ch.qos.logback.core.hook.DelayingShutdownHook"/&gt;
      .... 
  &lt;/configuration&gt;
</code></pre></li>
</ul>


<h2>五. 日志门面</h2>

<p>前面的四个框架是实际的日志框架。对于开发者而言，每种日志都有不同的写法。如果我们以实际的日志框架来进行编写，代码就限制死了，之后就很难再更换日志系统，很难做到无缝切换。</p>

<p>Java开发中经常提到面向接口编程，所以我们应该是按照一套统一的API来进行日志编程，实际的日志框架来实现这套API，这样的话，即使更换日志框架，也可以做到无缝切换。</p>

<p>这就是Commons-Logging与SLF4J这种日志门面框架的初衷。</p>

<h3>Apache Commons-Logging</h3>

<p>Apache Commons-Logging经常被简称为JCL，是Apache开源的日志门面框架。Spring中使用的日志框架就是JCL，使用起来非常简单。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import org.apache.commons.logging.LogFactory;
</span><span class='line'>
</span><span class='line'>private static final Log LOGGER = LogFactory.getLog(xx.class);
</span><span class='line'>
</span><span class='line'>LOGGER.info("...");</span></code></pre></td></tr></table></div></figure>


<p>使用JCL需要先引入JCL的依赖：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;dependency&gt;
</span><span class='line'>    &lt;groupId&gt;commons-logging&lt;/groupId&gt;
</span><span class='line'>    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
</span><span class='line'>    &lt;version&gt;xx&lt;/version&gt;
</span><span class='line'>&lt;/dependency&gt;</span></code></pre></td></tr></table></div></figure>


<p>再来看一下如何让JCL使用其他日志实现框架:</p>

<ol>
<li>这里当没有其他日志jar包存在的时候，JCL有自己的默认日志实现，默认的实现是对JUL的包装，即当没有其他任何日志包时，通过JCL调用的就是JUL做日志操作。</li>
<li>使用Log4j作为日志实现框架，那么只需要引入Log4j的jar包即可。</li>
<li><p>使用Log4j2作为日志实现，那么除了Log4j2的jar包，还需要引入Log4j2与Commons-Logging的集成包（使用SPI机制提供了自己的LogFactory实现）：</p>

<pre><code class="`"> &lt;dependency&gt;
     &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
     &lt;artifactId&gt;log4j-jcl&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre></li>
<li><p>使用Logback作为日志实现，那么由于Logback的调用是通过SLF4J的，因此需要引入jcl-over-slf4j包（直接覆盖了JCL的类），并同时引入SLF4J以及Logback的jar包。</p>

<pre><code class="`"> &lt;dependency&gt;
     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
     &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre></li>
</ol>


<h3>SLF4J</h3>

<p>SLF4J（Simple Logging Facade for Java）为Java提供的简单日志Facade。允许用户以自己的喜好，在工程中通过SLF4J接入不同的日志实现。与JCL不同的是，SLF4J只提供接口，没有任何实现（可以认为Logback是默认的实现）。</p>

<p>SLF4J的使用前提是引入SLF4J的jar包:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!-- SLF4J --&gt;
</span><span class='line'>&lt;dependency&gt;
</span><span class='line'>   &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
</span><span class='line'>   &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
</span><span class='line'>   &lt;version&gt;xx&lt;/version&gt;
</span><span class='line'>&lt;/dependency&gt;</span></code></pre></td></tr></table></div></figure>


<p>再看一下SLF4J如何和其他日志实现框架集成。</p>

<ol>
<li><p>使用JUL作为日志实现，需要引入slf4j-jdk14包。</p>

<pre><code class="`"> &lt;dependency&gt;
     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
     &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre></li>
<li><p>使用Log4j作为日志实现，需要引入slf4j-log4j12和log4j两个jar包。</p>

<pre><code class="`"> &lt;!-- slf4j-log4j --&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
     &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;

 &lt;!-- log4j --&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;log4j&lt;/groupId&gt;
     &lt;artifactId&gt;log4j&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre></li>
<li><p>使用Log4j2作为日志实现，需要引入log4j-slf4j-impl依赖。</p>

<pre><code class="`"> &lt;!-- log4j2 --&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
     &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
     &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
     &lt;version&gt;xx/version&gt;
 &lt;/dependency&gt;
 &lt;!-- log4j-slf4j-impl （用于log4j2与slf4j集成） --&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
     &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre></li>
<li><p>使用Logback作为日志实现，只需要引入logback包即可。</p></li>
</ol>


<h2>六. 日志集成</h2>

<p>上面说到了四种日志实现框架和两种日志门面框架。面对这么多的选择，即便是一个刚刚开始做的应用，也会由于依赖的第三方库使用的日志框架五花八门而造成日志配置和使用上的烦恼。得益于JCL和SLF4J，我们可以很容易的把日志都统一为一种实现，从而可以进行集中配置和使用。这里就以用Logback统一日志实现为例：</p>

<ol>
<li><p>配置好Logback的依赖：</p>

<pre><code class="`"> &lt;!-- slf4j-api --&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
     &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
     &lt;version&gt;xx&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;!-- logback --&gt;
 &lt;dependency&gt; 
     &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; 
     &lt;artifactId&gt;logback-core&lt;/artifactId&gt; 
     &lt;version&gt;xx&lt;/version&gt; 
 &lt;/dependency&gt;
 &lt;!-- logback-classic（已含有对slf4j的集成包） --&gt; 
 &lt;dependency&gt; 
     &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; 
     &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; 
     &lt;version&gt;xx&lt;/version&gt; 
 &lt;/dependency&gt;
</code></pre></li>
<li><p>切换Log4j到SLF4J</p>

<pre><code class="`"> &lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;
    &lt;version&gt;xx&lt;/verison&gt;
&lt;/dependency&gt;
</code></pre></li>
<li><p>切换JUL到SLF4J</p>

<pre><code class="`"> &lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;
    &lt;version&gt;xx&lt;/verison&gt;
 &lt;/dependency&gt;
</code></pre></li>
<li><p>切换JCL到SLF4J</p>

<pre><code class="`"> &lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
    &lt;version&gt;xx&lt;/verison&gt;
 &lt;/dependency&gt;
</code></pre></li>
</ol>


<p>这里需要注意的是，做了以上配置后，务必要排除其他日志包的存在，如Log4j。此外，在日常开发中经常由于各个依赖的库间接引入了其他日志库，造成日志框架的循环转换。比如同时引入了log4j-over-slf4j和slf4j-log4j12的情况，当使用SLF4J调用日志操作时就会形成循环调用。</p>

<p>笔者目前比较推崇的是使用SLF4J统一所有框架接口，然后都转换到Logback的底层实现。但这里需要说明的是Logback的作者是为了弥补Log4j的各种缺点而优化实现了SLF4J以及Logback，但不知为何作者又推出了Log4j2以期取代Log4j和Logback。所以，如果是一个新的项目，那么直接跳过Log4j和Logback选择Log4j2也是一个不错的选择, 官网也提供了Log4j到Log4j2的迁移说明。</p>

<blockquote><p>本文节选自《Java工程师修炼之道》一书。</p></blockquote>
</div>
  
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2019/05/30/msa/">微服务杂谈</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2019-05-30T11:29:34+00:00" pubdate data-updated="true">May 30<sup>th</sup>, 2019</time>
        
        
      </p>
    
  </header>


  <div class="post-content"><p>这几年在Java工程师招聘时，会看到很多人的简历都写着使用了Spring Cloud做微服务实现，使用Docker做自动化部署，并且也会把这些做为自己的亮点。而比较有趣的这其中以小公司出来的人为绝大多数，大的公司出来的人简历上倒是很少提这些东西。</p>

<p>对于我自己来说，从15年就开始关注这一块，看过马丁.福勒最开始的关于微服务的论文、也看过不少对微服务的论证的英文文章和书，也研究过Spring Cloud、Sofa等开源实现以及Service mesh。考虑到我们公司研发团队人力不足、基础设施不完善，当初是没有推行微服务的。但随着看到上述的那种简历越来越多，有时候我也会疑问：难道真的不用微服务就落后了吗？公司的同事如果不掌握这些就真的没有竞争力了吗。而随着最近公司业务的逐步提升，研发人员越来越多，借着在梳理公司的微服务落地计划时，也梳理了一下微服务的相关知识点，也是本文的主要内容。</p>

<p>开篇之前先声明我对微服务的几点态度:</p>

<blockquote><ol>
<li>架构模式有很多，微服务不是唯一的选择也不是什么银弹。国内绝大多数中小公司引入微服务都是在盲目追新，也能看出做此种技术选型的工程师基础架构素质的不足。</li>
<li>“你必须长的足够高才能使用微服务”。微服务基础设施，尤其是容器技术、自动化部署、自动化测试这些不完备，微服务形同虚设，不会带来什么质的提升。</li>
<li>微服务架构的关键不在于具体的实现，而在于如何合理地划分服务边界以及组织架构是否相匹配。不考虑研发团队的规模和组成就盲目上微服务是不良的技术选型。</li>
<li>Spring Boot是Spring全家桶的上层封装，并不是什么崭新的技术，也不是什么值得觉得成为自己杀手锏的技术。</li>
<li>Spring Cloud中Spring Cloud Netflix的组件是经过生产环境验证的，其他的则建议慎重选择。</li>
</ol>
</blockquote>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2019/05/30/msa/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2019/04/22/upforprogrammer/">这些知识决定了程序员的上限（PPT版）</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2019-04-22T11:29:34+00:00" pubdate data-updated="true">Apr 22<sup>nd</sup>, 2019</time>
        
        
      </p>
    
  </header>


  <div class="post-content"><p>讲述决定程序员上限的一些知识技能点，包括如何学习、如何阅读源码、计算机科学基础知识体系等。来自内部分享PPT，后续会发布<strong>详细版</strong>。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2019/04/22/upforprogrammer/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2019/04/13/netflix/">技术 in Netflix</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2019-04-13T11:29:34+00:00" pubdate data-updated="true">Apr 13<sup>th</sup>, 2019</time>
        
        
      </p>
    
  </header>


  <div class="post-content"><p>综合市面上的公开资料总结了Netflix在技术上面的一些实践和创新，从中能够得到不少启发和提示。</p>

<p><strong>来自公司内部分享</strong></p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2019/04/13/netflix/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2019/03/08/interview-basic/">技术面试的应该与不应该</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2019-03-08T11:29:34+00:00" pubdate data-updated="true">Mar 8<sup>th</sup>, 2019</time>
        
        
      </p>
    
  </header>


  <div class="post-content"><p>进入软件开发这个行业差不多10年，做为候选人被面试过，也做为面试官面试过别人。这几年做为后者的角色越来越多，慢慢总结出来了一些技术面试的原则，也是自己在实践的一些原则。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2019/03/08/interview-basic/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2019/02/25/cache/">缓存这些事</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2019-02-25T11:29:34+00:00" pubdate data-updated="true">Feb 25<sup>th</sup>, 2019</time>
        
        
      </p>
    
  </header>


  <div class="post-content"><p><strong>最新版本可见:<a href="https://github.com/superhj1987/pragmatic-java-engineer/blob/master/book/chapter5-datastore/cache.md">https://github.com/superhj1987/pragmatic-java-engineer/blob/master/book/chapter5-datastore/cache.md</a></strong></p>

<p>缓存是为了弥补持久化存储服务如数据库的性能缓慢而出现的一种将数据存储在内存中，从而大大提高应用性能的服务。如缓存五分钟法则所讲：如果一个数据频繁被访问，那么就应该放内存中。这里的缓存就是一种读写效率都非常高的存储方案，能够应对高并发的访问请求，通常情况下也不需要持久化的保证。但相对其他存储来说，缓存一般是基于内存的，成本比较昂贵，因此不能滥用。</p>

<p>缓存可以分为：本地缓存和分布式缓存。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2019/02/25/cache/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2019/01/26/my2018/">我的2018</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2019-01-26T11:29:34+00:00" pubdate data-updated="true">Jan 26<sup>th</sup>, 2019</time>
        
        
      </p>
    
  </header>


  <div class="post-content"><p>此文是我在部门内的一次公开信（经过脱敏），想法来自于《原则》和《谷歌是如何运营公司的》两本书。极度求真、 极度透明的原则是一个想要做出大事业的公司应该具有的气度，而对所有同事能够客观地陈述自己的得与失，并欢迎吐槽，这不仅仅是真诚文化、极度透明原则的体现，也是对自己的一种压力和驱动。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2019/01/26/my2018/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2018/12/08/kotlin-notes/">Kotlin语法简明指南</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2018-12-08T11:29:34+00:00" pubdate data-updated="true">Dec 8<sup>th</sup>, 2018</time>
        
        
      </p>
    
  </header>


  <div class="post-content"><p>Kotlin是Intellij IDEA的发明团队JetBrains带来的新一代JVM语言。虽然JVM上一次又一次出现新的语言叫嚣着取代Java，但时至今日，Java也开始吸纳其他语言的各种优势，其生命力依旧强盛，生态也越发强大。那么Kotlin的出现是又一次重蹈覆辙还是有其突破性的特性？</p>

<p>本文对其语法作了简要概括。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2018/12/08/kotlin-notes/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2018/11/22/online-debug/">如何应对在线故障</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2018-11-22T14:29:34+00:00" pubdate data-updated="true">Nov 22<sup>nd</sup>, 2018</time>
        
        
      </p>
    
  </header>


  <div class="post-content"><p>线上运行的Java应用突然没有响应、响应缓慢，进程突然消失，遇到这些情况应该如何应对呢？</p>

<p><strong>来自公司内部分享</strong></p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2018/11/22/online-debug/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
      <div class="page-navigator">
        
        
        
            <a href="/blog/posts/2" class="next">下一页>></a>
        
        <div class="center"><a href="/blog/archives">所有文章</a></div>
      </div>
     </div>
  </div>
    
  <aside id="secondary">
  <div id="sidebar">
  
    <section class="widget" style="font-size:9pt" id="copyright">
<p><span style="font-weight:bold">版权声明：</span>本博客所有文章为博主原创或翻译文章，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享4.0</a> 国际许可协议共享，转载请注明作者和原文链接。</p>
</section><section class="widget">
    <form action="http://cn.bing.com/search" method="get" target="_blank" onsubmit="return doSearch(this)">
    <div class="content">
      <input type="text" class="textfield searchtip" name="s" placeholder="请输入关键字" size="24" value="">
    </div>
    </form>
    <form action="http://cn.bing.com/search" method="get" target="_blank" style="display:none" name="frmSearch">
    <div class="content">
      <input type="hidden" name="q" value="">
    </div>
    </form>
</section>
<script type="text/javascript">
  function doSearch(o){
    var $s = $(o).find("input[name=s]");
    var $q = $(o).next("form").find("input[name=q]");
    $q.val($s.val() + " site:rowkey.me");
    $(o).next("form").submit();
    return false;
  }
</script><!--公告-->
<section class="widget" id="notice">
	<div style="margin-bottom: 10px">
		<h4 style="margin: 0px !important">梳理Java体系知识，沓实架构基础</h4>
		<a href="/blog/2018/04/01/pje-release/"><img src="/post_images/book.png" width="150"/></a>
	</div>
	<p>中华万年历/微鲤看看技术团队长期求<a href="https://m.zhipin.com/weijd/v2/job/0cdf0b4c4c3029521nN5392-FFc~" style="font-weight: bold" target="_blank">Java研发!!!</a>，感兴趣者可发送简历到<a href="mailto:hang@weli.cn">hang@weli.cn</a>。</p>
	<div style="margin-bottom: 10px">
		<h4 style="margin: 0px !important">关注公众号，及时获取最新文章</h4>
		<img src="/images/blog_images/mp-qrcode.jpg" style="margin-left: -20px" id="imgQR"/>
	</div>
	原博客：<a href="http://srhang.iteye.com/" target="_blank">http://srhang.iteye.com/</a>
</section><section class="widget" id="social">
		
		<a class="weibo" href="http://weibo.com/superhj1987" title="Weibo" target="_blank">Weibo</a>
		
		
			<a class="github" href="https://github.com/superhj1987" title="GitHub" target="_blank">GitHub</a>
		
		
		
		
			<a class="linkedin" href="http://www.linkedin.com/in/superhj1987" title="LinkedIn" target="_blank">LinkedIn</a>
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS" target="_blank">RSS</a>
		
</section><section class="widget">
	<h3 class="widget-title">最新文章</h3>
	<ul class="widget-list">
		
     	<li>
      	  <a href="/blog/2019/07/27/springboot/">使用Spring Boot快速开发</a>
      	</li>
    	
     	<li>
      	  <a href="/blog/2019/06/29/log/">Java开发框架之日志</a>
      	</li>
    	
     	<li>
      	  <a href="/blog/2019/05/30/msa/">微服务杂谈</a>
      	</li>
    	
     	<li>
      	  <a href="/blog/2019/04/22/upforprogrammer/">这些知识决定了程序员的上限（PPT版）</a>
      	</li>
    	
     	<li>
      	  <a href="/blog/2019/04/13/netflix/">技术 in Netflix</a>
      	</li>
    	
     	<li>
      	  <a href="/blog/2019/03/08/interview-basic/">技术面试的应该与不应该</a>
      	</li>
    	
     	<li>
      	  <a href="/blog/2019/02/25/cache/">缓存这些事</a>
      	</li>
    	
     	<li>
      	  <a href="/blog/2019/01/26/my2018/">我的2018</a>
      	</li>
    	
     	<li>
      	  <a href="/blog/2018/12/08/kotlin-notes/">Kotlin语法简明指南</a>
      	</li>
    	
     	<li>
      	  <a href="/blog/2018/11/22/online-debug/">如何应对在线故障</a>
      	</li>
    	
	</ul>
</section>
<section class="widget" style="margin-bottom: 0px !important">
	<h3 class="widget-title">最新评论</h3>
	<div id="recent-comments">暂无</div>
</section>


<section>
  <h3 class="widget-title">GitHub Repos</h3>
  <ul id="gh_repos" class="widget-list">
    <li class="loading">数据读取中&#8230;</li>
  </ul>
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'superhj1987',
            count: 3,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section class="widget">
	<h3 class="widget-title">技术酷站</h3>
	<ul class="widget-list">
     	<li><a href="http://toutiao.io/" target="_blank">开发者头条</a></li>
     	<li><a href="https://dzone.com/java-jdk-development-tutorials-tools-news" target="_blank">DZone - Java Zone</a></li>
		<li><a href="http://ifeve.com/" target="_blank">并发编程网</a></li>
	</ul>
</section>
  
  </div>
  </aside>
      	</div>
    </div>
  </div>
  <footer id="footer">
  	<div class="container">
	Copyright &copy; 2019 - 飒然Hang -
  <span class="credit">Powered by <a rel="nofollow" href="http://octopress.org">Octopress</a></span>
  - <span class="credit">Theme by <a rel="nofollow" href="http://pagecho.com">Cho</a></span>


</div>
<link href="/stylesheets/scrollUp.min.css" media="screen, projection" rel="stylesheet" type="text/css">
<script type="text/javascript" src="/javascripts/libs/jquery.scrollUp.min.js"></script>
<script src="//cdn.staticfile.org/marked/0.3.6/marked.min.js"></script>
<script src="//cdn.staticfile.org/timeago.js/3.0.1/timeago.min.js"></script>
<script src="//cdn.staticfile.org/spin.js/2.3.2/spin.min.js"></script>
<script src="//cdn.staticfile.org/highlight.js/9.10.0/highlight.min.js"></script>
<script type="text/javascript">
  marked.setOptions({
  highlight: function (code, lang) {
     return hljs.highlightAuto(code).value;
  }
  });
  function Highlighting(){
    var markdowns = document.getElementsByClassName('markdown');
    for(var i=0;i<markdowns.length;i++){
       if(markdowns[i].innerHTML) markdowns[i].innerHTML =marked(markdowns[i].innerHTML);
    }
  }
  window.addEventListener('DOMContentLoaded', Highlighting, false);
  window.addEventListener('load', Highlighting, false);
</script>
<script src="/javascripts/comment.js"></script>
<script type="text/javascript">
$(function(){
	$.scrollUp({
		appendId: 'footer'
	});
});
var opt = {
   type: "github",
   user: "superhj1987",
   repo: "superhj1987.github.io",
   no_comment: "还没有评论",
   go_to_comment: "点击评论",
   issue_title: "",
   btn_class: "btn_primary",
   comments_target: "#comment-thread",
   loading_target: "#loading-spin",
   client_id: "528dd6945e3a48c2a954",
   client_secret: "e71312e081ef3dd87cc3425ada7080cd3b296f0d"
};
getComments(opt);
opt = {
   type: "github",
   user: "superhj1987",
   repo: "superhj1987.github.io",
   recent_comments_target: "#recent-comments",
   count: 5,
   client_id: "528dd6945e3a48c2a954",
   client_secret: "e71312e081ef3dd87cc3425ada7080cd3b296f0d"
};
getRecentCommentsList(opt);
</script>

  </footer>
  











</body>
</html>
